# Типы индексов

## Хеш индекс

Хеш индекс представляет собой хеш-таблицу, которая хранится на диске.

Идея хеширования состоит в том, что значения любого типа данных равномерно распределяются по ограниченному количеству корзин хеш-таблицы с помощью функции хеширования.
Если хеш-таблица имеет достаточный размер, чтобы в одну корзину в среднем попадало одно значение (хеш-код), поиск значения в хеш-таблице выполняется за константное время.
Для этого:
- вычисляется хеш-функция от заданного значения
- по нескольким битам полученного хеш-кода определяется номер корзины
- корзина просматривается в поисках хеш-кода

Хеш-индекс хранит только значения хеш-функции и ссылки на версии строк.
Само индексируемое значение не сохраняется:
- размер хеш-индекса не зависит от размера ключа индексирования
- теряется возможность сканирования только индекса, значение можно прочитать только из таблицы

Размер хеш-индекса увеличивается динамически при добавлении новых значений.
При увеличении количество корзин удваивается. Рост размера происходит скачкообразно.

Ограничения:
- единственная поддерживаемая операция - поиск по условию равенства
- не поддерживается ограничение уникальности
- нельзя создавать многоколоночный индекс или добавить include столбцы

В некоторых случаях хеш-индекс может работать быстрее, чем B-дерево, за счет меньшего размера и фиксированного времени поиска.

Посмотрим план запроса:
```sql
EXPLAIN (costs off)
SELECT * FROM seats WHERE seat_no = '31D';

                QUERY PLAN                 
-------------------------------------------
 Seq Scan on seats
   Filter: ((seat_no)::text = '31D'::text)
(2 rows)
```

Поскольку подходящего индекса нет, используется последовательное сканирование.
Создадим хеш-индекс по полю "seat_no":
```sql
CREATE INDEX ON seats USING hash(seat_no);

CREATE INDEX
```

Повторим запрос:
```sql
EXPLAIN (costs off)
SELECT * FROM seats WHERE seat_no = '31D';

                     QUERY PLAN                      
-----------------------------------------------------
 Bitmap Heap Scan on seats
   Recheck Cond: ((seat_no)::text = '31D'::text)
   ->  Bitmap Index Scan on seats_seat_no_idx
         Index Cond: ((seat_no)::text = '31D'::text)
(4 rows)
```

Теперь планировщик использует хеш-индекс и строит битовую карту.
Поменяем условие равенства на "больше":
```sql
EXPLAIN (costs off)
SELECT * FROM seats WHERE seat_no > '31D';

                QUERY PLAN                 
-------------------------------------------
 Seq Scan on seats
   Filter: ((seat_no)::text > '31D'::text)
(2 rows)
```

С неравенствами хеш-индекс использоваться не может.


## GIST индекс

GiST расшифровывается как generalized search tree - обобщенное дерево поиска.
Это сбалансированное дерево.

Рассмотрим идею такого индекса на примере точек на плоскости.
Плоскость разбивается на несколько прямоугольников, которые в сумме покрывают все точки.
Эти прямоугольники составляют верхний уровень дерева.
На следующем уровне дерева каждый из больших прямоугольников распадается на прямоугольники меньшего размера.
И так далее.
На последнем уровне дерева каждый ограничивающий прямоугольник будет содержать столько точек, сколько помещается на одну индексную страницу.

Такое разбиение позволяет быстро находить точки, лежащие внутри определенной области.
Такой алгоритм индексирования называется R-деревом.

Для демонстрации работы GiST индекса обратимся к таблице "airports_data" (на этой таблице построено представление "airports").
В таблице есть поле "coordinates" типа `point`, по нему и будем строить GiST индекс.

Но сначала выполним следующий запрос - найдем все аэропорты, находящиеся недалеко от Москвы:
```sql
EXPLAIN (costs off) SELECT airport_code FROM airports_data WHERE coordinates <@ '<(37.622513,55.753220),1.0>'::circle;

                          QUERY PLAN                           
---------------------------------------------------------------
 Seq Scan on airports_data
   Filter: (coordinates <@ '<(37.622513,55.75322),1>'::circle)
(2 rows)
```

Без индекса просматривается вся таблица. Создадим GiST-индекс:
```sql
CREATE INDEX airports_gits_idx ON airports_data USING gist(coordinates);

CREATE INDEX
```

Таблица "airposts_data" невелика, поэтому планировщик все равно будет использовать последовательное сканирование.
Временно отключим этот метод доступа:
```sql
SET enable_seqscan = off;

SET
```

Повторим запрос:
```sql
EXPLAIN (costs off) SELECT airport_code FROM airports_data WHERE coordinates <@ '<(37.622513,55.753220),1.0>'::circle;

                            QUERY PLAN                             
-------------------------------------------------------------------
 Index Scan using airports_gits_idx on airports_data
   Index Cond: (coordinates <@ '<(37.622513,55.75322),1>'::circle)
(2 rows)
```

Теперь планировщик получает нужные строки, обращаясь к индексу "airports_gits_idx".

Удалим созданный индекс:
```sql
DROP INDEX airports_gits_idx;

DROP INDEX
```


## SP-GIST

SP-GiST расшифровывается как space partitioning GiST.
Это тоже обобщенное дерево, но области, на которые разбивается плоскость, не пересекаются.
Это несбалансированное дерево.

Рассмотрим пример индекса SP-GiST для точек на плоскости.
Один из вариантов - дерево квадрантов.
Корневой узел разбивает плоскость на четыре части (квадранта) по отношению к выбранной точке (центроиду).
Далее каждый из 4-х квадрантов делится на собственные квадранты.
Разбиение продолжается, пока все точки в квадранте не станут помещаться на одну индексную страницу.

SP-GiST, как и GiST, является каркасом, на основе которого, реализуя классы операторов, можно строить произвольные схемы индексации.
Например, дерево квадрантов для точек реализуется классом операторов `point_ops`.
Другой способ деления плоскости на две части (сначала по горизонтали, потом по вертикали), а не на четыре, называется k-мерным деревом и реализуется классом операторов `kd_point_ops`.

Создадим индекс SP-GiST по полю "coordinates" в таблице "airports_data".
Для точек есть два класса операторов.
По умолчанию используется `point_ops` (дерево квадрантов), мы для примера укажем `kd_point_ops` (k-мерное дерево):
```sql
CREATE INDEX airports_spgist_idx ON airports_data USING spgist(coordinates kd_point_ops);

CREATE INDEX
```

Попробуем найти все аэропорты, расположенные выше (севернее) Надыма:
```sql
EXPLAIN (costs off) SELECT airport_code FROM airports_data WHERE coordinates >^ '(72.69889831542969,65.48090362548828)'::point;

                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Bitmap Heap Scan on airports_data
   Recheck Cond: (coordinates >^ '(72.69889831542969,65.48090362548828)'::point)
   ->  Bitmap Index Scan on airports_spgist_idx
         Index Cond: (coordinates >^ '(72.69889831542969,65.48090362548828)'::point)
(4 rows)
```

Теперь вся таблица сканируется по битовой карте, построенной на основе SP-GiST индекса "airports_spgist_idx".

Удалим индекс:
```sql
DROP INDEX airports_spgist_idx;

DROP INDEX
```

Включим обратно последовательное сканирование:
```sql
RESET enable_seqscan;

RESET
```