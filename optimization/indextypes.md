# Типы индексов

## Хеш индекс

Хеш индекс представляет собой хеш-таблицу, которая хранится на диске.

Идея хеширования состоит в том, что значения любого типа данных равномерно распределяются по ограниченному количеству корзин хеш-таблицы с помощью функции хеширования.
Если хеш-таблица имеет достаточный размер, чтобы в одну корзину в среднем попадало одно значение (хеш-код), поиск значения в хеш-таблице выполняется за константное время.
Для этого:
- вычисляется хеш-функция от заданного значения
- по нескольким битам полученного хеш-кода определяется номер корзины
- корзина просматривается в поисках хеш-кода

Хеш-индекс хранит только значения хеш-функции и ссылки на версии строк.
Само индексируемое значение не сохраняется:
- размер хеш-индекса не зависит от размера ключа индексирования
- теряется возможность сканирования только индекса, значение можно прочитать только из таблицы

Размер хеш-индекса увеличивается динамически при добавлении новых значений.
При увеличении количество корзин удваивается. Рост размера происходит скачкообразно.

Ограничения:
- единственная поддерживаемая операция - поиск по условию равенства
- не поддерживается ограничение уникальности
- нельзя создавать многоколоночный индекс или добавить include столбцы

В некоторых случаях хеш-индекс может работать быстрее, чем B-дерево, за счет меньшего размера и фиксированного времени поиска.

Посмотрим план запроса:
```sql
EXPLAIN (costs off)
SELECT * FROM seats WHERE seat_no = '31D';

                QUERY PLAN                 
-------------------------------------------
 Seq Scan on seats
   Filter: ((seat_no)::text = '31D'::text)
(2 rows)
```

Поскольку подходящего индекса нет, используется последовательное сканирование.
Создадим хеш-индекс по полю "seat_no":
```sql
CREATE INDEX ON seats USING hash(seat_no);

CREATE INDEX
```

Повторим запрос:
```sql
EXPLAIN (costs off)
SELECT * FROM seats WHERE seat_no = '31D';

                     QUERY PLAN                      
-----------------------------------------------------
 Bitmap Heap Scan on seats
   Recheck Cond: ((seat_no)::text = '31D'::text)
   ->  Bitmap Index Scan on seats_seat_no_idx
         Index Cond: ((seat_no)::text = '31D'::text)
(4 rows)
```

Теперь планировщик использует хеш-индекс и строит битовую карту.
Поменяем условие равенства на "больше":
```sql
EXPLAIN (costs off)
SELECT * FROM seats WHERE seat_no > '31D';

                QUERY PLAN                 
-------------------------------------------
 Seq Scan on seats
   Filter: ((seat_no)::text > '31D'::text)
(2 rows)
```

С неравенствами хеш-индекс использоваться не может.
