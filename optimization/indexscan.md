# Индексное сканирование

Рассмотрим таблицу бронирований:
```sql
\d bookings

                        Table "bookings.bookings"
    Column    |           Type           | Collation | Nullable | Default
--------------+--------------------------+-----------+----------+---------
 book_ref     | character(6)             |           | not null |
 book_date    | timestamp with time zone |           | not null |
 total_amount | numeric(10,2)            |           | not null |
Indexes:
    "bookings_pkey" PRIMARY KEY, btree (book_ref)
Referenced by:
    TABLE "tickets" CONSTRAINT "tickets_book_ref_fkey" FOREIGN KEY (book_ref) REFERENCES bookings(book_ref)
```
Столбец `book_ref` является первичным ключом и для него автоматически был создан индекс `bookings_pkey`.

Проверим план запроса с поиском одного значения:
```sql
EXPLAIN SELECT * FROM bookings WHERE book_ref = 'CDE08B';

                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Index Scan using bookings_pkey on bookings  (cost=0.43..8.45 rows=1 width=21)
   Index Cond: (book_ref = 'CDE08B'::bpchar)
(2 rows)
```
План:
- `Index Scan` - доступ по индексу, указано имя использованного индекса
- `Index Cond` - условие доступа

## Как формируется стоимость?

Первое число `0.43` - оценка ресурсов для спуска к листовому узлу.
Она зависит от логарифма количества листовых узлов (количества операций сравнения, которые надо выполнить) и от высоты дерева.
При оценке считается, что необходимые страницы окажутся в кэше и оцениваются только ресурсы процессора: цифра получается небольшой.

Спуститься от корня индекса до листовой странички, после этого мы получим ссылку на табличную строку и будем готовы ее извлекать.

Второе число `8.45` - оценка чтения необходимых листовых страниц индекса и табличных страниц.
Не стоит забывать, что один узел `Index Scan` подразумевает обращение и к индексу, и к таблице.

В данном случае, поскольку индекс уникальный, будет прочитана одна индексная страница и одна табличная.
Каждое из чтений оценивается параметром:
```sql
SELECT current_setting('random_page_cost');

 current_setting 
-----------------
 4               
(1 row)
```

Его значение по умолчанию больше, чем `seq_page_cost`, поскольку произвольный доступ стоит дороже.
Хотя для SSD-дисков этот параметр следует существенно уменьшать (до `2`, до `1.5` или даже до `1.1`).

Итого получаем `8`, и еще немного добавляет оценка процессорного времени на обработку строк.

## Дополнительные условия

Дополнительные условия, которые можно проверить только по таблице, отображаются в отдельной строке `Filter`:
```sql
EXPLAIN SELECT * FROM bookings WHERE book_ref = 'CDE08B' AND total_amount > 1000;

                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Index Scan using bookings_pkey on bookings  (cost=0.43..8.45 rows=1 width=21) 
   Index Cond: (book_ref = 'CDE08B'::bpchar)                                   
   Filter: (total_amount > '1000'::numeric)                                    
(3 rows)
```


## Параллельное индексное сканирование

Индексное сканирование может выполняться в параллельном режиме.
В качестве примера найдем сумму одной четверти всех бронирований:

```sql
EXPLAIN SELECT sum(total_amount) FROM bookings WHERE book_ref < '400000';

                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 Finalize Aggregate  (cost=16861.86..16861.87 rows=1 width=32)
   ->  Gather  (cost=16861.64..16861.85 rows=2 width=32)
         Workers Planned: 2
         ->  Partial Aggregate  (cost=15861.64..15861.65 rows=1 width=32)
               ->  Parallel Index Scan using bookings_pkey on bookings  (cost=0.43..15312.03 rows=219843 width=6)
                     Index Cond: (book_ref < '400000'::bpchar)
(6 rows)
```
Аналогичный план мы уже видели при параллельном последовательном сканировании,
но в данном случае данные читаются с помощью индекса - узел `Parallel Index Scan`.

Стоимость обусловлена двумя составляющими.
Во-первых, стоимость доступа к `1/4` табличных страниц, поделенных между процессами - аналогично последовательному сканированию:
```sql
SELECT
  round(
    (relpages / 4.0) * current_setting('seq_page_cost')::real +
    (reltuples / 4.0) / 2.4 * current_setting('cpu_tuple_cost')::real
  )
FROM pg_class WHERE relname = 'bookings';

 round 
-------
  5561
(1 row)
```

Вторая составляющая - индексный доступ (не делится между процессами, т.к. индекс читается процессами последовательно, страница за страницей):
```sql
SELECT
  round(
    (relpages / 4.0) * current_setting('random_page_cost')::real +
    (reltuples / 4.0) * current_setting('cpu_index_tuple_cost')::real +
    (reltuples / 4.0) * current_setting('cpu_operator_cost')::real
  )
FROM pg_class WHERE relname = 'bookings_pkey';

 round 
-------
  9750
(1 row)
```
Стоимость `cpu_operator_cost` учитывает необходимость сравнения значений (операция "меньше либо равно").

Сложим `9750` и `5561` - получим `15311` (полная стоимость `Parallel Index Scan`).


## Исключительно индексное сканирование

Если вся необходимая информация содержится в самом индексе, то нет необходимости обращаться к таблице - за исключением проверки видимости:
```sql
EXPLAIN SELECT book_ref FROM bookings WHERE book_ref <= '100000';

                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Index Only Scan using bookings_pkey on bookings  (cost=0.43..4180.24 rows=146732 width=7)
   Index Cond: (book_ref <= '100000'::bpchar)
(2 rows)


```
Вопрос в каком состоянии у нас была карта видимости и действительно ли при выборе такого метода доступа мы не обращаемся к табличным строкам.

Узнать это можно только выполнив запрос.

Посмотрим план с помощью EXPLAIN ANALYZE. Этот вариант команды EXPLAIN не просто показывает план,
но и реально выполняет запрос, и вывод содержит больше полезных сведений.
```sql
EXPLAIN (ANALYZE, COSTS OFF, TIMING OFF) SELECT book_ref FROM bookings WHERE book_ref <= '100000';

                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Index Only Scan using bookings_pkey on bookings (actual rows=132109 loops=1)
   Index Cond: (book_ref <= '100000'::bpchar)
   Heap Fetches: 0
 Planning Time: 0.046 ms
 Execution Time: 28.348 ms
(5 rows)
```
`EXPLAIN ANALYZE` для каждого узла в плане после слова `actual` показывает:
- `rows` - сколько реально строк было выбрано `132109`
- `loops` - сколько раз выполнялся узел плана `1`

Дополнительные параметры в плане:
- `Heap Fetches` - сколько строк было проверено с помощью таблицы `0`
- `Planning Time` - сколько времени ушло на построение плана (число разное от раза к разу)
- `Execution Time` - сколько времени ушло на выполнение запроса (число разное от раза к разу)



Таким образом мы сможем сравнивать, о чем планировщик думал, когда строил план, и что реально получилось в процессе выполнения.

В нашем случае не пришлось обращаться к таблице, потому что очистка таблицы выполнялась, следовательно, и карта видимости обновлена:
```sql
SELECT vacuum_count, autovacuum_count FROM pg_stat_all_tables WHERE relname = 'bookings';

 vacuum_count | autovacuum_count 
--------------+------------------
            0 |                1
(1 row)
```

Выполним очистку таблицы:
```sql
VACUUM bookings;

VACUUM
```


## Параллельное исключительно индексное сканирование

Выполним запрос:
```sql
EXPLAIN SELECT count(book_ref) FROM bookings WHERE book_ref <= '400000';

                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Finalize Aggregate  (cost=13499.01..13499.02 rows=1 width=8)
   ->  Gather  (cost=13498.80..13499.01 rows=2 width=8)
         Workers Planned: 2
         ->  Partial Aggregate  (cost=12498.80..12498.81 rows=1 width=8)
               ->  Parallel Index Only Scan using bookings_pkey on bookings  (cost=0.43..11949.09 rows=219881 width=7)
                     Index Cond: (book_ref <= '400000'::bpchar)
(6 rows)
```

Стоимость доступа к таблице здесь учитывает только обработку строк, без ввода-вывода:
```sql
SELECT
  round(
    (reltuples / 4.0) / 2.4 * current_setting('cpu_tuple_cost')::real
  )
FROM pg_class WHERE relname = 'bookings';

 round 
-------
  2199
(1 row)
```
Вклад индексного доступа остается прежним - `9750`. Добавим `2199` и получим `11949` (полная стоимость узла `Parallel Index Only Scan`).

Дальше мы не будем подробно останавливаться на расчете стоимости.
Для этого используется достаточно сложная математическая модель.
В нашу задачу входит только показать общий принцип.


## Сортировка

Есть два способа выполнить сортировку.
Первый - получить строки сканированием подходящего индекса, в этом случае данные автоматически будут отсортированы:

```sql
EXPLAIN SELECT * FROM flights ORDER BY flight_id;

                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Index Scan using flights_pkey on flights  (cost=0.42..8248.95 rows=214867 width=63)
(1 row)
```

Тот же самый индекс может использоваться и для получения строк в обратном порядке:
```sql
EXPLAIN SELECT * FROM flights ORDER BY flight_id DESC;

                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Index Scan Backward using flights_pkey on flights  (cost=0.42..8248.95 rows=214867 width=63)
(1 row)
```
В этом случае мы спускаемся от корня дерева к правому листовому узлу, и проходим по списку листовых страниц в обратном порядке.

Второй способ - выполнить последовательное сканирование таблицы и затем отсортировать полученные данные.
Чтобы посмотреть на план такого запроса, запретим индексный доступ (аналогично можно запретить и другие методы доступа):

