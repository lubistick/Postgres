# Выполнение запросов


## Простые запросы

Протокол простых запросов применяется, когда на сервер отправляется команда с оператором `SELECT` или команда с оператором `RETURNING`.

Отправим простой запрос:
```sql
SELECT model FROM aircrafts WHERE aircraft_code = '773';

     model     
---------------
 Боинг 777-300
(1 row)
```

Обработка запроса состоит из нескольких шагов:

1. Разбор
2. Переписывание
3. Планирование
4. Выполнение


### Синтаксический разбор

Когда посылаем серверу запрос в текстовом виде, Postgres разбирает его синтаксически:
- Есть ли опечатки? И т.д.


### Семантический разбор

Затем Postgres разбирает запрос семантически:

- Есть ли объект `aircrafts` в базе данных?
- Что это за объект?
- Есть ли права на него? И т.д.

Информация о том, какие вообще объекты есть в базе данных, и какими свойствами они обладают, хранится в системном каталоге и используется на этапе разбора.
Результатом разбора является синтаксическое дерево запроса.


### Переписывание

Затем происходит переписывание (трансформация). Частный случай переписывания - подстановка текста запроса вместо имени представления.


### Планирование

Планировщик перебирает различные способы выполнения запроса и оценивает их.
Он может менять порядок соединения таблиц, способы соединения, способы доступа к данным и тд.
Выбирает план с наименьшей стоимостью. Стоимость зависит от типа узла в дереве и числа строк, которые надо обработать.

Чтобы понять, сколько строк надо обработать, нужна статистика.


### Выполнение

Далее запрос выполняется в соответствии с выбранным планом, и результат возвращается клиенту.


## Подготовленные операторы

Создадим подготовленный оператор для запроса:
```sql
PREPARE model(varchar) AS SELECT model FROM aircrafts WHERE aircraft_code = $1;

PREPARE
```
После выполнения этой команды произошли `разбор` и `переписывание`.
Синтаксическое дерево запоминается в локальной памяти обслуживающего процесса.

Теперь можем вызвать оператор по имени:
```sql
EXECUTE model('773');

     model     
---------------
 Боинг 777-300
(1 row)
```

Посмотрим все подготовленные операторы:
```sql
SELECT * FROM pg_prepared_statements \gx

-[ RECORD 1 ]---+--------------------------------------------------------------------------------
name            | model
statement       | PREPARE model(varchar) AS SELECT model FROM aircrafts WHERE aircraft_code = $1;
prepare_time    | 2023-09-15 20:45:16.68741+00
parameter_types | {"character varying"}
from_sql        | t
generic_plans   | 0
custom_plans    | 1
```

Все подготовленные операторы пропадут при завершении сеанса.

Удалим подготовленный оператор в текущем сеансе:
```sql
DEALLOCATE model;

DEALLOCATE
```


## Курсоры

Курсоры дают возможность построчной обработки результата. Их можно открыть только внутри транзакции.

Откроем транзакцию:
```sql
BEGIN;

BEGIN
```

Откроем курсор:
```sql
DECLARE c CURSOR FOR SELECT * FROM aircrafts;

DECLARE CURSOR
```

Прочитаем первую строку результата:
```sql
FETCH c;

 aircraft_code |     model     | range 
---------------+---------------+-------
 773           | Боинг 777-300 | 11100
(1 row)
```

Прочитаем следующую строку результата:
```sql
FETCH c;

 aircraft_code |     model     | range 
---------------+---------------+-------
 763           | Боинг 767-300 |  7900
(1 row)
```

Закроем курсор:
```sql
CLOSE c;

CLOSE CURSOR
```

Закроем транзакцию:
```sql
COMMIT;

COMMIT
```

- Запрос без курсора - планировщик оптимизирует время всей выборки.
- Запрос с курсором - планировщик оптимизирует время получения первых строк.

Минимизируется стоимость для получения доли строк, которая задается параметром `cursor_tuple_fraction`.
По умолчанию оптимизируется время получения первых 10% строк из всей выборки:
```sql
SHOW cursor_tuple_fraction;

 cursor_tuple_fraction
-----------------------
 0.1
(1 row)
```


## Журнал сообщений сервера

Время выполнения каждого этапа обработки запроса можно увидеть в логах сервера.

Текущий файл журнала сообщений сервера отсутствует:
```sql
select pg_current_logfile();

 pg_current_logfile 
--------------------

(1 row)
```

Включим сборщик сообщений:
```sql
ALTER SYSTEM SET logging_collector = on;

ALTER SYSTEM
```

Хотим видеть в журнале примерное время выполнения `разбора` и `переписывания` запроса:
```sql
ALTER SYSTEM SET log_parser_stats = on;

ALTER SYSTEM
```

А также время `планирования` запроса:
```sql
ALTER SYSTEM SET log_planner_stats = on;

ALTER SYSTEM
```

И время `выполнения` запроса:
```sql
ALTER SYSTEM SET log_executor_stats = on;

ALTER SYSTEM
```

Для применения значений перезапустим сервер:
```bash
docker stop postgres-demo

postgres-demo
```
```bash
docker start postgres-demo

postgres-demo
```

Проверим, что появился файл журнала сообщений:
```sql
select pg_current_logfile();

          pg_current_logfile          
--------------------------------------
 log/postgresql-2023-09-15_103003.log
(1 row)
```

## Explain Analyze

Команда `EXPLAIN ANALYZE` не только показывает план запроса, но и выполняет сам запрос.:
```sql
EXPLAIN (ANALYZE, COSTS OFF, TIMING OFF)
SELECT * FROM ticket_flights;

                        QUERY PLAN                        
----------------------------------------------------------
 Seq Scan on ticket_flights (actual rows=8391852 loops=1)
 Planning Time: 0.091 ms
 Execution Time: 340.455 ms
(3 rows)
```

`Seq Scan` - полное сканирование таблицы.

`Planning Time` - общее время для `разбора`, `переписывания` и `планирования`.

`Execution Time` - время `выполнения`.

Первый раз запрос будет выполняться ДОЛЬШЕ, чем последующие разы.
За счет того, что заполняются различные кэши.

Благодаря установленным выше параметрам из журнала сообщений можно получить более подробную информацию.
Выведем только основные цифры:
```bash
\! tail -n 60 /var/lib/postgresql/data/log/postgresql-2023-09-15_103003.log | egrep 'LOG: |elapsed'

2023-09-15 11:16:45.742 UTC [84] LOG:  PARSER STATISTICS
        !       0.000016 s user, 0.000004 s system, 0.000019 s elapsed
2023-09-15 11:16:45.742 UTC [84] LOG:  PARSE ANALYSIS STATISTICS
        !       0.000045 s user, 0.000012 s system, 0.000056 s elapsed
2023-09-15 11:16:45.742 UTC [84] LOG:  REWRITER STATISTICS
        !       0.000001 s user, 0.000000 s system, 0.000001 s elapsed
2023-09-15 11:16:45.742 UTC [84] LOG:  PLANNER STATISTICS
        !       0.000048 s user, 0.000013 s system, 0.000061 s elapsed
2023-09-15 11:16:46.078 UTC [84] LOG:  EXECUTOR STATISTICS
        !       0.260243 s user, 0.080169 s system, 0.335671 s elapsed
```
- `PARSER STATISTICS` - синтаксический разбор
- `PARSE ANALYSIS STATISTICS` - семантический разбор
- `REWRITER STATISTICS` - трансформация запроса
- `PLANNER STATISTICS` - планирование
- `EXECUTOR STATISTICS` - выполнение

В Explain Analyze и логах тысячные доли отличаются, это нормально:

- Время выполнения в Explain Analyze - 340.455 ms.
- Время выполнения в логах - 0.335671 s


## Селективность и кардинальность

- Селективность - доля выбираемых строк.
- Кардинальность - итоговое число строк.

Например, в дереве есть узел, который читает все данные из таблицы `pg_namespace`.
У нас нет никаких условий, поэтому селективность равна единице.


## Влияние подготовленных операторов на время выполнения


### Долгий запрос

Вычислим среднюю стоимость одного билета:
```sql
SELECT AVG(amount) FROM ticket_flights;

        avg         
--------------------
 19949.000423267713
(1 row)
```

Включим счетчик времени:
```sql
\timing on
    
Timing is on.
```

Помним, что время выполнения одного и того же запроса может отличаться от раза к разу.
Чтобы сгладить разницу, выполним запрос 10 раз в цикле с помощью языка `PL/pgSQL` и посчитаем среднее время:
```sql
DO $$
  BEGIN
    FOR i IN 1..10 LOOP
      EXECUTE 'SELECT AVG(amount) FROM ticket_flights';
    END LOOP;
  END;
$$ LANGUAGE plpgsql;

DO
Time: 6198.412 ms (00:06.198)
```

Теперь с подготовленным оператором (вместо `EXECUTE SELECT` используем `PERFORM`):
```sql
DO $$
  BEGIN
    FOR i IN 1..10 LOOP
      PERFORM AVG(amount) FROM ticket_flights;
    END LOOP;
  END;
$$ LANGUAGE plpgsql;

DO
Time: 6183.818 ms (00:06.184)
```
Время изменилось незначительно или можно считать, что не изменилось, т.к. большую часть занимает `выполнение` запроса.


### Быстрый запрос

Получим данные о бронировании `0824C5`:
```sql
SELECT * FROM bookings WHERE book_ref = '0824C5';

 book_ref |       book_date        | total_amount 
----------+------------------------+--------------
 0824C5   | 2017-07-25 20:36:00+00 |    112400.00
(1 row)
```

Выполним этот же запрос 10 раз и посчитаем среднее время:
```sql
DO $$
  BEGIN
    FOR i IN 1..10 LOOP
      EXECUTE 'SELECT * FROM bookings WHERE book_ref = ''0824C5''';
    END LOOP;
  END;
$$ LANGUAGE plpgsql;

DO
Time: 3.300 ms
```

Теперь с подготовленным оператором:
```sql
DO $$
  BEGIN
    FOR i IN 1..10 LOOP
      PERFORM * FROM bookings WHERE book_ref = '0824C5';
    END LOOP;
  END;
$$ LANGUAGE plpgsql;

DO
Time: 1.198 ms
```

Время сократилось существенно - `разбор` и `планирование` занимает большую часть общего времени.
