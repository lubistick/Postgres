# Выполнение запросов

Обработка запроса состоит из нескольких шагов:

1. Разбор
2. Переписывание
3. Планирование
4. Выполнение

## Журнал сообщений сервера

Время выполнения каждого этапа обработки запроса можно увидеть в логах сервера.

Текущий файл журнала сообщений сервера отсутствует:
```sql
select pg_current_logfile();

 pg_current_logfile 
--------------------

(1 row)
```

Включим сборщик сообщений:
```sql
ALTER SYSTEM SET logging_collector = on;

ALTER SYSTEM
```

Хотим видеть в журнале примерное время выполнения `разбора` и `переписывания` запроса:
```sql
ALTER SYSTEM SET log_parser_stats = on;

ALTER SYSTEM
```

А также время `планирования` запроса:
```sql
ALTER SYSTEM SET log_planner_stats = on;

ALTER SYSTEM
```

И время `выполнения` запроса:
```sql
ALTER SYSTEM SET log_executor_stats = on;

ALTER SYSTEM
```

Для применения значений перезапустим сервер:
```bash
docker stop postgres-demo

postgres-demo
```
```bash
docker start postgres-demo

postgres-demo
```

Проверим, что появился файл журнала сообщений:
```sql
select pg_current_logfile();

          pg_current_logfile          
--------------------------------------
 log/postgresql-2023-09-15_103003.log
(1 row)
```

## Этапы выполнение запросов

Посмотрим план запроса:
```sql
EXPLAIN (ANALYZE, COSTS OFF, TIMING OFF)
SELECT * FROM ticket_flights;

                        QUERY PLAN                        
----------------------------------------------------------
 Seq Scan on ticket_flights (actual rows=8391852 loops=1)
 Planning Time: 0.091 ms
 Execution Time: 340.455 ms
(3 rows)
```
План простой - полное сканирование таблицы `Seq Scan`.
Команда `EXPLAIN ANALYZE` не только показывает план запроса, но и выполняет сам запрос.
`Planning Time` - общая цифра для планирования и разбора.

Благодаря установленным выше параметрам из журнала сообщений можно получить более подробную информацию.
Выведем только основные цифры:
```bash
\! tail -n 60 /var/lib/postgresql/data/log/postgresql-2023-09-15_103003.log | egrep 'LOG: |elapsed'

2023-09-15 11:16:45.742 UTC [84] LOG:  PARSER STATISTICS
        !       0.000016 s user, 0.000004 s system, 0.000019 s elapsed
2023-09-15 11:16:45.742 UTC [84] LOG:  PARSE ANALYSIS STATISTICS
        !       0.000045 s user, 0.000012 s system, 0.000056 s elapsed
2023-09-15 11:16:45.742 UTC [84] LOG:  REWRITER STATISTICS
        !       0.000001 s user, 0.000000 s system, 0.000001 s elapsed
2023-09-15 11:16:45.742 UTC [84] LOG:  PLANNER STATISTICS
        !       0.000048 s user, 0.000013 s system, 0.000061 s elapsed
2023-09-15 11:16:46.078 UTC [84] LOG:  EXECUTOR STATISTICS
        !       0.260243 s user, 0.080169 s system, 0.335671 s elapsed
```
- `PARSER STATISTICS` - синтаксический разбор
- `PARSE ANALYSIS STATISTICS` - семантический разбор
- `REWRITER STATISTICS` - трансформация запроса
- `PLANNER STATISTICS` - планирование
- `EXECUTOR STATISTICS` - выполнение

### Синтаксический разбор

Посылаем серверу запрос в текстовом виде `SELECT * FROM t`.

Postgres разбирает запрос синтаксически.

Есть ли опечатки? И тд.

### Семантический разбор

Postgres разбирает запрос семантически.

Есть ли объект `t` в базе данных? Что это за объект? Есть лы права на него? И тд.

Информация о том, какие вообще объекты есть в базе данных, и какими свойствами они обладают, хранится в системном каталоге и используется на этапе разбора.
Результатом разбора является синтаксическое дерево запроса.

### Переписывание

### Планирование

Планировщик может варьировать разные параметры: может менять порядок соединения таблиц, способы соединения, способы доступа к данным и тд.
Выбирает план с наименьшей стоимостью. Стоимость зависит от типа узла в дереве и числа строк, которые надо обработать.

Чтобы понять, сколько строк надо обработать, нужна статистика.

### Выполнение

Имеются разные способы выполнения запроса:

1. Простой - непосредственное выполнение и получение результата.
2. Расширенный - подготовленные операторы и курсоры.

## Простые запросы

Протокол простых запросов применяется, когда на сервер отправляется команда с оператором `SELECT` или команда с оператором `RETURNING`.

Отправим простой запрос:
```sql
SELECT model FROM aircrafts WHERE aircraft_code = '773';

     model     
---------------
 Боинг 777-300
(1 row)
```

## Подготовленные операторы

Создадим подготовленный оператор для запроса:
```sql
PREPARE model(varchar) AS SELECT model FROM aircrafts WHERE aircraft_code = $1;

PREPARE
```
После выполнения этой команды произошли разбор и переписывание.
Синтаксическое дерево запоминается в локальной памяти обслуживающего процесса.

Теперь можем вызвать оператор по имени:
```sql
EXECUTE model('773');

     model     
---------------
 Боинг 777-300
(1 row)
```

Посмотрим все подготовленные операторы:
```sql
SELECT * FROM pg_prepared_statements \gx

-[ RECORD 1 ]---+--------------------------------------------------------------------------------
name            | model
statement       | PREPARE model(varchar) AS SELECT model FROM aircrafts WHERE aircraft_code = $1;
prepare_time    | 2023-09-15 20:45:16.68741+00
parameter_types | {"character varying"}
from_sql        | t
generic_plans   | 0
custom_plans    | 1
```

Все подготовленные операторы пропадут при завершении сеанса.

Удалим подготовленный оператор в текущем сеансе:
```sql
DEALLOCATE model;

DEALLOCATE
```

## Курсоры

Курсоры дают возможность построчной обработки результата. По умолчанию курсоры живут в пределах одной транзакции.

Курсор можно открыть только внутри транзакции. Откроем транзакцию:
```sql
BEGIN;

BEGIN
```

Откроем курсор:
```sql
DECLARE c CURSOR FOR SELECT * FROM aircrafts;

DECLARE CURSOR
```

Прочитаем первую строку результата:
```sql
FETCH c;

 aircraft_code |     model     | range 
---------------+---------------+-------
 773           | Боинг 777-300 | 11100
(1 row)
```

Прочитаем вторую строку результата:
```sql
FETCH c;

 aircraft_code |     model     | range 
---------------+---------------+-------
 763           | Боинг 767-300 |  7900
(1 row)
```

Закроем курсор:
```sql
CLOSE c;

CLOSE CURSOR
```

Закроем транзакцию:
```sql
COMMIT;

COMMIT
```

- Запрос без курсора - планировщик оптимизирует время всей выборки.
- Запрос с курсором - планировщик оптимизирует время получения первых строк.

Минимизируется стоимость для получения доли строк, которая задается параметром `cursor_tuple_fraction`.
По умолчанию оптимизируется время получения первых 10% строк из всей выборки:
```sql
SHOW cursor_tuple_fraction;

 cursor_tuple_fraction
-----------------------
 0.1
(1 row)
```

## Селективность и кардинальность

- Селективность - доля выбираемых строк.
- Кардинальность - итоговое число строк.

Например, в дереве есть узел, который читает все данные из таблицы `pg_namespace`.
У нас нет никаких условий, поэтому селективность равна единице.


---
Нужно вычислить среднее время, потому что первый раз запрос будет выполняться, как правило, дольше.
А следующие разы - меньшее время. За счет того, что заполняются различные кеши.


```sql

```
