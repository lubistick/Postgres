# Последовательное сканирование

При последовательном чтении всех страниц:
- страницы читаются в кеш (используется буферное кольцо)
- проверяется видимость версий строк
- данные возвращаются в произвольном порядке
- время сканирования зависит от физического размера файла

В плане выполнения запроса последовательное сканирование представлено узлом `Seq Scan`:
```sql
EXPLAIN SELECT * FROM flights;

                           QUERY PLAN                           
----------------------------------------------------------------
 Seq Scan on flights  (cost=0.00..4772.67 rows=214867 width=63)
(1 row)
```

Значения в скобках:
- `cost` - оценка стоимости
- `rows` - оценка числа строк, которые планировщик предполагает выбрать
- `width` - оценка размера одной записи в байтах, не стоит обращать на нее внимание, она нужна планировщику, чтобы знать, сколько памяти выделять

Стоимость `cost` указывается в условных единицах и состоит из двух компонент:
- Начальная стоимость вычисления узла. Для последовательного сканирования это ноль - чтобы возвращать данные, подготовки не требуется.
- Полная стоимость для получения всех данных.

## Как рассчитывается стоимость?

У планировщика есть математическая модель, по которой он считает эти числа. Она учитывает:
- дисковый ввод-вывод
- ресурсы процессора

### Оценка дискового ввода-вывода

Рассчитывается как произведение числа СТРАНИЦ (не строк) в таблице на условную стоимость чтения одной страницы:
```sql
SELECT
  relpages,
  current_setting('seq_page_cost'),
  relpages * current_setting('seq_page_cost')::real AS total
FROM pg_class WHERE relname = 'flights';

 relpages | current_setting | total 
----------+-----------------+-------
     2624 | 1               |  2624
(1 row)
```

Стоимость чтения при последовательном сканировании равна единице. Обычно эту оценку никогда не меняют, чтобы была некая точка отсчета.

### Оценка ресурсов процессора

Складывается из стоимости обработки каждой строки:
```sql
SELECT
  reltuples,
  current_setting('cpu_tuple_cost'),
  reltuples * current_setting('cpu_tuple_cost')::real AS total
FROM pg_class WHERE relname = 'flights';

 reltuples | current_setting |  total  
-----------+-----------------+---------
    214867 | 0.01            | 2148.67
(1 row)
```

Сумма чисел `2624` и `2148.67` и есть общая стоимость `4772.67`.

## Последовательное сканирование и агрегация

Более сложный запрос с агрегатной функцией:
```sql
EXPLAIN SELECT COUNT(*) FROM seats;

                          QUERY PLAN                           
---------------------------------------------------------------
 Aggregate  (cost=24.74..24.75 rows=1 width=8)
   ->  Seq Scan on seats  (cost=0.00..21.39 rows=1339 width=0)
(2 rows)
```

План состоит из двух узлов:
- снизу `Seq Scan` - последовательный доступ к таблице, поскольку нужны все строки
- сверху узел `Aggregate`, который подсчитывает количество строк

Узел `Aggregate` получает данные от нижнего узла `Seq Scan`.
Начальная стоимость агрегации практически равна полной.
Это означает, что узел не может выдать результат, пока не обработает все данные.

### Оценка узла агрегации

Разница между нижней оценкой `24.74` для `Aggregate` и верхней оценкой `21.39` для `Seq Scan` - стоимость работы узла `Aggregate`.
Вычисляется исходя из оценки ресурсов процессора на выполнение элементарной операции:
```sql
SELECT
  reltuples,
  current_setting('cpu_operator_cost'),
  reltuples * current_setting('cpu_operator_cost')::real AS total
FROM pg_class WHERE relname = 'seats';

 reltuples | current_setting |   total   
-----------+-----------------+-----------
      1339 | 0.0025          | 3.3474998
(1 row)
```

Число примерно `3.35` - и есть разница между `24.74` и `21.39`.
