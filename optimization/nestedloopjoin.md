# Соединения

Способы соединения - не соединения SQL
inner/left/right/full/cross join/in/exists - логические операции
способы соединения - механизм реализации

Соединяются не таблицы, а наборы строк
могут быть получены от любого узла дерева плана

Наборы строк соединяются попарно
порядок соединений важен с точки зрения производительности
обычно важен и порядок внутри пары

SELECT a.title, s.name FROM albums a JOIN songs s ON a.id = s.album_id;
для каждой строки одного набора
перебираем подходящие строки другого набора
индексный доступ или полное сканирование

Вычислительная сложность
N * M
где N и M - число строк во внешнем и внутреннем наборах данных
эффективно только для небольшого числа строк

В параллельном режиме
внешний набор строк сканируется параллельно,
внутренний - последовательно одним из рабочих процессов


## Вложенный цикл (Nested Loop)

Так выглядит план для соединения вложенным циклом,
которое оптимизатор обычно предпочитает для небольших выборок (смотрим перелеты, включенные в два билета):

```sql
EXPLAIN (costs off)
SELECT * FROM tickets t
JOIN ticket_flights tf ON tf.ticket_no = t.ticket_no
WHERE t.ticket_no IN ('0005432312163', '0005432312164');

                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Nested Loop
   ->  Index Scan using tickets_pkey on tickets t
         Index Cond: (ticket_no = ANY ('{0005432312163,0005432312164}'::bpchar[]))
   ->  Index Scan using ticket_flights_pkey on ticket_flights tf
         Index Cond: (ticket_no = t.ticket_no)
(5 rows)
```

План запроса:
- Узел `Nested Loop` обращается к первому (внешнему) набору за первой строкой.
Здесь это - узел `Index Scan` по билетам `tickets`.
- Узел `Nested Loop` обращается ко второму (внутреннему) набору и просит выдать все строки,
соответствующие строке первого набора.
Здесь это - узел `Index Scan` по перелетам `ticket_flights`.
- Процесс повторяется до тех пор, пока внешний набор не исчерпает все строки.


Посмотрим на оцененую стоимость.

```sql
EXPLAIN
SELECT * FROM tickets t
JOIN ticket_flights tf ON tf.ticket_no = t.ticket_no
WHERE t.ticket_no IN ('0005432312163', '0005432312164');

                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Nested Loop  (cost=0.99..46.10 rows=6 width=136)
   ->  Index Scan using tickets_pkey on tickets t  (cost=0.43..12.89 rows=2 width=104)
         Index Cond: (ticket_no = ANY ('{0005432312163,0005432312164}'::bpchar[]))
   ->  Index Scan using ticket_flights_pkey on ticket_flights tf  (cost=0.56..16.57 rows=3 width=32)
         Index Cond: (ticket_no = t.ticket_no)
(5 rows)
```

- Начальная стоимость `Nested Loop` (`0.99`) - сумма первых компонент стоимости дочерних узлов `Index Scan` (`0.43` и `0.56`).
- Конечная стоимость `Nested Loop` складывается из:
    - стоимости получения данных от внешнего набора (вторая компонента `Index Scan` по билетам `tickets`)
    - стоимости получения данных от внутреннего набора (вторая компонента `Index Scan` по перелетам `ticket_flights`), умноженной на число строк внешнего набора (`2` строки)
    - процессорного времени на обработку строк

В общем случае формула более сложная, но основной вывод: стоимость пропорциональна `N * M`, где `N` и `M` - число строк в соединяемых наборах данных.


Выполним `EXPLAIN ANALYZE`:

```sql
EXPLAIN (costs off, ANALYZE)
SELECT * FROM tickets t
JOIN ticket_flights tf ON tf.ticket_no = t.ticket_no
WHERE t.ticket_no IN ('0005432312163', '0005432312164');

                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Nested Loop (actual time=3.602..4.898 rows=8 loops=1)
   ->  Index Scan using tickets_pkey on tickets t (actual time=0.066..0.085 rows=2 loops=1)
         Index Cond: (ticket_no = ANY ('{0005432312163,0005432312164}'::bpchar[]))
   ->  Index Scan using ticket_flights_pkey on ticket_flights tf (actual time=1.770..2.396 rows=4 loops=2)
         Index Cond: (ticket_no = t.ticket_no)
 Planning Time: 0.572 ms
 Execution Time: 4.974 ms
(7 rows)
```

Плане запроса:
- `loops` имеет значение `1` - сколько раз выполнялся вложенный цикл.
- `rows` имеет значение `8` - сколько в среднем было выбрано строк. Видно, что планировщик немного ошибся - получилось `8` строк вместо `6`.
- `time` - сколько потрачено времени за один раз.

Предупреждение: вывод времени выполнения каждого шага, как в этом примере, может существенно замедлять выполнение запроса на некоторых платформах.
Если такая информация не нужна, лучше указывать фразу `TIMING OFF`.


## Модификации

Существует несколько модификаций алгоритма. Для левого соединения:

EXPLAIN (COSTS OFF) SELECT * FROM aircrafts a LEFT JOIN seats s ON a.aircraft_code = s.aircraft_code WHERE a.model LIKE 'Аэробус%';

[результат]

Эта модификация возвращает строки, даже если для левого (a) набора строк не нашлось соответствия в правом (s) наборе.

Такая же модификация есть и для правого соединения.
Но надо помнить что планировщик сам определяет порядок, в котором соединяются таблицы,
независимо от того, как они перечислены в запросе.


Антисоединение возвращает строки одного набора, если только для них не нашлось соответствия в другом наборе.
Такая модификация может использоваться для обработки предиката NOT EXISTS:

EXPLAIN (COSTS OFF) SELECT * FROM aircrafts a WHERE a.model LIKE 'Аэробус%' AND NOT EXISTS (SELECT * FROM seats s WHERE s.aircraft_code = a.aircraft_code);

[результат]

Таже операция антисоединения используется и для аналогичного запроса, записанного иначе:

EXPLAIN (COSTS OFF) SELECT * FROM aricrafts a LEFT JOIN seats s ON a.aircraft_code = s.aircraft_code WHERE a.model LIKE 'Аэробус%' AND s.aircraft_code IS NULL;

[результат]


Для предиката EXISTS может использоваться полусоединение, которое возвращает строки одного набора,
если для них нашлось хотя бы одно соответствие в другом наборе.

EXPLAIN SELECT * FROM aircrafts a WHERE a.model LIKE 'Аэробус%' AND EXISTS (SELECT * FROM seats s WHERE s.aircraft_code = a.aircraft_code);

[результат]

Обратите внимание: хотя в плане для таблицы s указано rows 149, на самом деле достаточно получить всего одну строку, чтобы понять значение предиката EXISTS.

PostgreSQL так и делает (actual rows):

EXPLAIN (COSTS OFF, ANALYZE) SELECT * FROM aircrafts a WHERE a.model LIKE 'Аэробус%' AND EXISTS (SELECT * FROM seats s WHERE s.aircraft_code = a.aircraft_code);

[результат]

Модификации алгоритма вложенного цикла для полного соединения (FULL JOIN) не существует.
Это связано с тем, что полный проход по второму набору строк может не выполняться.
Если пренебречь производительностью, полное соединение можно получить, объединив левое соединение и антисоединение.
Такой способ может пригодиться, т.к. FULL JOIN (как мы увидим позже) работает только с эквисоединениями.


## Соединение нескольких таблиц.

Найдем всех пассажиров, купивших билеты на определенный рейс:

EXPLAIN (COSTS OFF) SELECT t.passenger_name FROM tickets t JOIN ticket_flight tf ON tf.ticket_no = t.ticket_no JOIN flights f ON f.flight_id = tf.flight_id WHERE f.flight_id = 12345;

[результат]

На верхнем уровне используется соединение вложенным циклом. Внешний набор данных состоит из одной строки,
полученной из таблицы рейсов (flights) по уникальному индексу.

Для получения внутреннего набора используется параллельный план.
Каждый из процессов читает свою часть таблицы перелетов (tickets_flights) и соединяет ее с билетами (tickets) с помощью другого вложенного цикла.
