# Соединения

Способы соединения - не соединения SQL
inner/left/right/full/cross join/in/exists - логические операции
способы соединения - механизм реализации

Соединяются не таблицы, а наборы строк
могут быть получены от любого узла дерева плана

Наборы строк соединяются попарно
порядок соединений важен с точки зрения производительности
обычно важен и порядок внутри пары

SELECT a.title, s.name FROM albums a JOIN songs s ON a.id = s.album_id;
для каждой строки одного набора
перебираем подходящие строки другого набора
индексный доступ или полное сканирование

Вычислительная сложность
N * M
где N и M - число строк во внешнем и внутреннем наборах данных
эффективно только для небольшого числа строк

В параллельном режиме
внешний набор строк сканируется параллельно,
внутренний - последовательно одним из рабочих процессов


## Nested Loop

Так выглядит план для соединения вложенным циклом,
которое оптимизатор обычно предпочитает для небольших выборок (смотрим перелеты, включенные в два билета):

EXPLAIN (costs off) SELECT * FROM tickets t JOIN ticket_flights tf ON tf.ticked_no = t.ticket_no WHERE t.ticket_no IN ('0005432312164', '0005432312164');

[результат]

- Узел Nested Loop обращается к первому (внешнему) набору за первой строкой.
Здесь это - узел Index Scan по билетам.
- Затем Nested Loop обращается ко второму (внутреннему) набору и просит выдать все строки,
соответствующие строке первого набора.
Здесь это - узел Index Scan по перелетам.
- Процесс повторяется до тех пор, пока внешний набор не исчерпает все строки.


Посмотрим на оцененую стоимость.
EXPLAIN SELECT * FROM tickets t JOIN ticket_flights tf ON tf.ticked_no = t.ticket_no WHERE t.ticket_no IN ('0005432312164', '0005432312164');

[результат]

Первая компонента стоимости Nested Loop - сумма первых компонент стоимости дочерних узлов (Index Scan).

Вторая компонента стоимости Nested Loop складывается из:
- стоимости получения данных от внешнего набора (вторая компонента Index Scan по билетам)
- стоимости получения данных от внутреннего набора (вторая компонента Index Scan по перелетам), умноженной на число строк внешнего набора (2 строки)
- процессорного времени на обработку строк

В общем случае формула более сложная, но основной вывод: стоимость пропорциональна N * M, где N и M - число строк в соединяемых наборах данных.


Команда EXPLAIN ANALYZE позволяет узнать, сколько раз на самом деле выполнялся вложенный цикл (loops)
и сколько в среднем было выбрано строк (rows) и потрачено времени (time) за один раз.
Видно, что планировщик немного ошибся - получилось 8 строк вместо 6.

EXPLAIN (costs off, ANALYZE) SELECT * FROM tickets t JOIN ticket_flights tf ON tf.ticked_no = t.ticket_no WHERE t.ticket_no IN ('0005432312164', '0005432312164');

[результат]

Предупреждение: вывод времени выполнения каждого шага, как в этом примере, может существенно замедлять выполнение запроса на некоторых платформах.
Если такая информация не нужна, лучше указывать фразу TIMING OFF.


## Модификации

Существует несколько модификаций алгоритма. Для левого соединения:

EXPLAIN (COSTS OFF) SELECT * FROM aircrafts a LEFT JOIN seats s ON a.aircraft_code = s.aircraft_code WHERE a.model LIKE 'Аэробус%';

[результат]

Эта модификация возвращает строки, даже если для левого (a) набора строк не нашлось соответствия в правом (s) наборе.

Такая же модификация есть и для правого соединения.
Но надо помнить что планировщик сам определяет порядок, в котором соединяются таблицы,
независимо от того, как они перечислены в запросе.


Антисоединение возвращает строки одного набора, если только для них не нашлось соответствия в другом наборе.
Такая модификация может использоваться для обработки предиката NOT EXISTS:

EXPLAIN (COSTS OFF) SELECT * FROM aircrafts a WHERE a.model LIKE 'Аэробус%' AND NOT EXISTS (SELECT * FROM seats s WHERE s.aircraft_code = a.aircraft_code);

[результат]

Таже операция антисоединения используется и для аналогичного запроса, записанного иначе:

EXPLAIN (COSTS OFF) SELECT * FROM aricrafts a LEFT JOIN seats s ON a.aircraft_code = s.aircraft_code WHERE a.model LIKE 'Аэробус%' AND s.aircraft_code IS NULL;

[результат]


Для предиката EXISTS может использоваться полусоединение, которое возвращает строки одного набора,
если для них нашлось хотя бы одно соответствие в другом наборе.

EXPLAIN SELECT * FROM aircrafts a WHERE a.model LIKE 'Аэробус%' AND EXISTS (SELECT * FROM seats s WHERE s.aircraft_code = a.aircraft_code);

[результат]

Обратите внимание: хотя в плане для таблицы s указано rows 149, на самом деле достаточно получить всего одну строку, чтобы понять значение предиката EXISTS.

PostgreSQL так и делает (actual rows):

EXPLAIN (COSTS OFF, ANALYZE) SELECT * FROM aircrafts a WHERE a.model LIKE 'Аэробус%' AND EXISTS (SELECT * FROM seats s WHERE s.aircraft_code = a.aircraft_code);

[результат]

Модификации алгоритма вложенного цикла для полного соединения (FULL JOIN) не существует.
Это связано с тем, что полный проход по второму набору строк может не выполняться.
Если пренебречь производительностью, полное соединение можно получить, объединив левое соединение и антисоединение.
Такой способ может пригодиться, т.к. FULL JOIN (как мы увидим позже) работает только с эквисоединениями.


## Соединение нескольких таблиц.

Найдем всех пассажиров, купивших билеты на определенный рейс:

EXPLAIN (COSTS OFF) SELECT t.passenger_name FROM tickets t JOIN ticket_flight tf ON tf.ticket_no = t.ticket_no JOIN flights f ON f.flight_id = tf.flight_id WHERE f.flight_id = 12345;

[результат]

На верхнем уровне используется соединение вложенным циклом. Внешний набор данных состоит из одной строки,
полученной из таблицы рейсов (flights) по уникальному индексу.

Для получения внутреннего набора используется параллельный план.
Каждый из процессов читает свою часть таблицы перелетов (tickets_flights) и соединяет ее с билетами (tickets) с помощью другого вложенного цикла.
