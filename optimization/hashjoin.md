# Соединение хешированием

Вычислительная сложность N + M, где N и M - число строк в первом и втором наборах данных.
Начальные затраты на построение хеш-таблицы.
Эффективно для большого числа строк.

Оперативная память.
Память каждой операции ограничена параметром work_mem.
При выполнении запроса несколько операций могут использовать память одновременно.
Если выделенной памяти не хватает, используется диск (иногда операция может и превысить ограничение).
Больше памяти - быстрее выполнение.

Дисковая память.
Общая дисковая память сеанса ограничена параметром temp_file_limit (без учета временных таблиц).


Размер хеш-таблицы в памяти ограничен значением work_mem * hash_mem_multiplier.


## Алгоритм Hash Join

Для большой выборки оптимизатор предпочитает соединение хешированием.
```sql
EXPLAIN (COSTS OFF) SELECT * FROM tickets t
JOIN ticket_flights tf ON tf.ticket_no = t.ticket_no;

                QUERY PLAN                 
-------------------------------------------
 Hash Join
   Hash Cond: (tf.ticket_no = t.ticket_no)
   ->  Seq Scan on ticket_flights tf
   ->  Hash
         ->  Seq Scan on tickets t
(5 rows)
```

Сначала выполняется узел `Seq Scan` по таблице `tickets` (билеты).
Для каждой строки `tickets` вычисляется хеш-функция от значений полей, входящих в условие соединения (поле `ticket_no`).
В корзину хеш-таблицы помещаются вычисленный хеш-код и все поля,
которые входят в условие соединения (поле `ticket_no`) или используются в запросе (все поля двух таблиц, т.к. указана `*`).

Затем выполняется `Seq Scan` по таблице `ticket_flights` (перелеты).
Для каждой строки `ticket_flights` вычисляется хеш-функция.
Проверяется корзина, соответствующая вычисленному значению.
Если есть корзина, то проверяются значения полей в условиях соединения.

Проверки только хеш-кода не достаточно, т.к. возможны коллизии, при которых разные значения получат одинаковые хеш-коды.


### Стоимость

Посмотрим на стоимость:
```sql
EXPLAIN SELECT * FROM tickets t JOIN ticket_flights tf ON tf.ticket_no = t.ticket_no;
```

Первая компонента стоимости узла Hash Join складывается из:
- стоимости получения всего первого набора данных (здесь - билеты).
- стоимости построения хеш-таблицы - пока таблица не готова, соединение не может начаться.

Вторая компонента стоимости складывается из:
- стоимости получения всего второго набора данных (здесь - перелеты).
- стоимости проверки по хеш-таблице.
- стоимости обращения к диску в случае, когда предполагается использование более одного пакета.

Главный вывод: стоимость хеш-соединения пропорциональна N + M, где N и M - число строк в соединяемых наборах данных.
При больших N и M это значительно выгоднее, чем произведение в случае соединения внешним циклом.


## Модификации

Модификации Hash Join включают уже рассмотренные Left, Semi и Anti, а также Full для полного соединения:
```sql
EXPLAIN SELECT * FROM aircrafts a FULL JOIN seats s ON a.aircraft_code = s.aircraft_code;
```


## Группировка и уникальные значения

Для группировки (GROUP BY) и устранения дубликатов (DISTINCT и операции со множествами без слова ALL) используются методы, схожие с методами соединения.
Один из способов выполнения состоит в том, чтобы построить хеш-таблицу по нужным полям и получить из нее уникальные значения.

```sql
EXPLAIN SELECT fare_conditions, count(*) FROM seats GROUP BY fare_conditions;
```

Тоже самое и с DISTINCT:
```sql
EXPLAIN SELECT DISTINCT fare_conditions FROM seats;
```


## Использование памяти

Значение work_mem по умолчанию:
```sql
SHOW work_mem;
```

Увеличим размер:
```sql
SET work_mem = '128MB';
```

```sql
EXPLAIN (COSTS OFF, TIMING OFF, ANALYZE) SELECT * FROM bookings b JOIN tickets t ON b.book_ref = t.book_ref;
```

Хеш-таблица поместилась в память (Batches: 1).
Параметр Buckets показывает число корзин в хеш-таблице, а Memory Usage - использованную оперативную память.
Обратите внимание, что хеш-таблица строилась по меньшему набору строк.

Сравним с таким же запросом, который выводит только одно поле:
```sql
EXPLAIN (COSTS OFF, TIMING OFF, ANALYZE) SELECT b.book_ref FROM bookings b JOIN tickets t ON b.book_ref = t.book_ref; 
```

Расход памяти уменьшился, т.к. в хем-таблице теперь только одно поле (вместо трех).

Обратите внимание на строку Hash Cond: она содержит предикаты, участвующие в соединении.
Условие может включать и такие предикаты, которые не могут использоваться механизмом соединения, но должны учитываться.
Они отображаются в отдельной строке Join Filter и тоже попадают в хеш-таблицу (сравните объем памяти):
```sql
EXPLAIN (COSTS OFF, TIMING OFF, ANALYZE) SELECT b.book_ref FROM bookings b JOIN tickets t ON b.book_ref = t.book_ref AND b.total_amount::text > t.passenger_id;
```

Теперь уменьшим work_mem так, чтобы хеш-таблица не поместилась, и включим вывод сообщений о временных файлах:
```sql
SET work_mem = '32MB';
```

```sql
SET log_temp_files = 0;
```
Если в нашем сеансе будут создаваться временные файлы размером больше, чем 0 байт, значит информацию о них нужно записывать в журнал.
Можно поставить размер больше, если маленькие файлы нас не интересуют.
Но нас в принципе интересует, какие файлы создавались.

```sql
EXPLAIN (COSTS OFF, TIMING OFF, ANALYZE) SELECT b.book_ref FROM bookings b JOIN tickets t ON b.book_ref = t.book_ref; 
```

Время выполнения запроса возросло.
Потребовалось 4 пакета: один из них сразу же загружается в оперативную память, а для 3-х других создадутся файлы на диске.
Т.е. 3 файла, которые потом будут загружаться в хеш-таблицу и еще 3 файла для второго набора данных.

Посмотрим сообщения о временных файлах в журнале - поскольку были использованы 4 пакета, то файлов будет (4 - 1) * 2 = 6:
```bash
tail -n 18 /var/log/postgresql/postgresql-10-main.log (исправить путь)
```

По размеру видно, что часть файлов относится к первой таблице (они меньше), а часть - ко второй (они больше).

Информацию об использовании временных файлов и вообще о вводе-выводе может показать и сама команда EXPLAIN с указанием BUFFERS:
```sql
EXPLAIN (COSTS OFF, TIMING OFF, ANALYZE, BUFFERS) SELECT b.book_ref FROM bookings b JOIN tickets t ON b.book_ref = t.book_ref; 
```

- Hash: temp written - страницы пакетов, записанные при построении хеш-таблицы.
- Hash Join: temp read/written - чтение и запись временных файлов на этапе соединения.


## Соединение нескольких таблиц

Пример плана с двумя соединениями хешированием (имена пассажиров и рейсы):
```sql
EXPLAIN (COSTS OFF) SELECT t.passenger_name, f.flight_no FROM tickets t
JOIN ticket_flights tf ON tf.ticket_no = t.ticket_no
JOIN flights f ON f.flight_id = tf.flight_id;
```

Сначала соединяются билеты (tickets) и перелеты (ticket_flights), причем хеш-таблица строится по таблице билетов.
Затем получившийся набор строк соединяется с перелетами (flights), по которым строится другая хеш-таблица.


Соединение хешированием требует подготовки.
Надо построить хеш таблицу.

Эффективно для больших выборок.

Зависит от порядка соединения.
Внутренний набор должен быть меньше внешнего, чтобы минимизировать хеш-таблицу.

Поддерживает только эквисоединения.
Для хеш-кодов операторы "больше" и "меньше" не имеют смысла.
