# Соединение слиянием

Чтобы начать соединение, необходимо чтобы оба набора данных были отсортированы по ключу соединения.
Либо сортировка в оперативной памяти (work_mem).
Либо получение отсортированных данных индексным сканированием.

Результат соединения автоматически отсортирован.

Вычислительная сложность:
N + M, где N и M - число строк в первом и втором наборах данных, если не требуется сортировка.
N logN + M logM, если сортировка нужна.


Создание индекса.

Индексная сортировка.
Сначала все строки сортируются.
Затем строки собираются в листовые индексные страницы.
Ссылки на них собираются в страницы следующего уровня и т.д., пока не дойдем до корня.

Ограничение.
maintenance_work_mem, т.к. операция не частая.
Для уникальных индексов требуется дополнительно work_mem.


## Merge Join

Если результат необходим в отсортированном виде, оптимизатор может предпочесть соединение слиянием.
Особенно, если данные от дочерних узлов можно получить уже отсортированными с помощью индексного сканирования:
```sql
EXPLAIN (COSTS OFF) SELECT * FROM tickets t JOIN ticket_flights tf ON tf.ticket_no = t.ticket_no ORDER BY t.ticket_no;
```

Посмотрим на стоимость:
```sql
EXPLAIN SELECT * FROM tickets t JOIN ticket_flights tf ON tf.ticket_no = t.ticket_no ORDER BY t.ticket_no;
```

Первая компонента включает:
- сумму первых компонент стоимостей дочерних узлов (включают стоимость сортировки, если она необходима)
- стоимость получения первой пары строк, соответствующих друг другу.







```sql

```