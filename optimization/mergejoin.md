# Соединение слиянием

Чтобы начать соединение, необходимо чтобы оба набора данных были отсортированы по ключу соединения.
Либо сортировка в оперативной памяти (work_mem).
Либо получение отсортированных данных индексным сканированием.

Результат соединения автоматически отсортирован.

Вычислительная сложность:
N + M, где N и M - число строк в первом и втором наборах данных, если не требуется сортировка.
N logN + M logM, если сортировка нужна.


Создание индекса.

Индексная сортировка.
Сначала все строки сортируются.
Затем строки собираются в листовые индексные страницы.
Ссылки на них собираются в страницы следующего уровня и т.д., пока не дойдем до корня.

Ограничение.
maintenance_work_mem, т.к. операция не частая.
Для уникальных индексов требуется дополнительно work_mem.


## Merge Join

Если результат необходим в отсортированном виде, оптимизатор может предпочесть соединение слиянием.
Особенно, если данные от дочерних узлов можно получить уже отсортированными с помощью индексного сканирования:
```sql
EXPLAIN (COSTS OFF) SELECT * FROM tickets t JOIN ticket_flights tf ON tf.ticket_no = t.ticket_no ORDER BY t.ticket_no;
```

Посмотрим на стоимость:
```sql
EXPLAIN SELECT * FROM tickets t JOIN ticket_flights tf ON tf.ticket_no = t.ticket_no ORDER BY t.ticket_no;
```

Первая компонента включает:
- сумму первых компонент стоимостей дочерних узлов (включают стоимость сортировки, если она необходима).
- стоимость получения первой пары строк, соответствующих друг другу.

Вторая компонента стоимости складывается из:
- суммы стоимостей получения обоих наборов данных.
- стоимости сравнения строк.


В отличие от соединения хешированием, слияние без сортировки хорошо подходит для случая, когда надо быстро получить первые строки:
```sql
EXPLAIN SELECT * FROM tickets t JOIN ticket_flights tf ON tf.ticket_no = t.ticket_no ORDER BY t.ticket_no LIMIT 1000;
```

Обратите внимание и на то, как уменьшилась общая стоимость.


Если нужного индекса не окажется, придется выполнять сортировку в узле Sort.
Тогда первая компонента стоимости будет не меньше стоимости сортировки, и первые строки запрос не сможет выдавать без задержки.
Вот пример такого плана (здесь явная сортировка выбрана из-за небольшого размера таблицы):
```sql
EXPLAIN SELECT * FROM aircrafts a JOIN seats s ON a.aircraft_code = s.aircraft_code ORDER BY a.aircraft_code;
```


## Группировка и уникальные значения

Как мы видели, для устранения дубликатов может использоваться  хеширование.
Другой способ - сортировка значений:
```sql
EXPLAIN SELECT DISTINCT book_date FROM bookings ORDER BY book_date;
```

Сортировка и устранение дубликатов происходит в узле Unique.
Для группировки будет использоваться узел с другим названием - GroupAggregate.

Такой способ особенно выгоден, если требуется получить отсортированный результат (как в данном случае).


## Использование памяти при сортировке

Еще один случай, когда сортировка оказывается выгодней - ограниченная оперативная память.
Алгоритм внешней сортировки работает эффективней, чем хеш-соединение и использованием нескольких пакетов.

Включим сообщения о временных файлах и посмотрим, как выполняется сортировка.
```sql
SET log_temp_files = 0;
```

```sql
EXPLAIN (COSTS OFF, TIMING OFF, ANALYZE) SELECT DISTINCT book_date FROM bookings;
```

Строки не помещаются в доступную память и используется внешняя сортировка (Sort Method: external merge).

Также в журнале сообщений мы видим запись о временном файле:
```bash
tail -n 4 /val/log/....исправить путь
```

Запись появляется, когда файл освобождается, поэтому его размер известен.

Теперь увеличим work_mem:
```sql
SET work_mem = '32MB';
```

Выполним тот же запрос:
```sql
EXPLAIN (COSTS OFF, TIMING OFF, ANALYZE) SELECT DISTINCT book_date FROM bookings;
```

Поскольку сортировка не требуется и памяти достаточно, планировщик переключился на использование хеширования.

Но если добавить предложение ORDER BY, планировщик возвращается к сортировке.
Он будет строить хеш-таблицу, а ее результат в конце отсортирует:
```sql
EXPLAIN (COSTS OFF, TIMING OFF, ANALYZE) SELECT DISTINCT book_date FROM bookings ORDER BY book_date;
```

Теперь все строки поместились в память (Sort Method: quicksort).


## Соединение нескольких таблиц

Пример запроса с двумя соединениями слиянием (номера билетов и места в салоне):
```sql
EXPLAIN (COSTS OFF) SELECT t.ticket_no, bp.flight_id, bp.seat_no FROM tickets t
JOIN ticket_flights tf ON t.ticket_no = tf.ticket_no
JOIN boarding_passes bp ON bp.ticket_no = tf.ticket_no AND bp.flight_id = tf.flight_id
ORDER BY t.ticket_no;
```

Здесь соединяются tickets (билеты) и boarding_passes (посадочные талоны),
и с этим, уже отсортированным по номерам билетов, набором строк соединяются ticket_flights (перелеты).
