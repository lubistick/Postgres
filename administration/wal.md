# Буферный кэш и журнал предварительной записи

## Буферный кэш

В общей памяти экземпляра отводится какая-то часть памяти, которая представляет собой массив буферов.
Каждый буфер хранит в себе одну страницу данных плюс дополнительную информацию - откуда эта страница была прочитана, в каком она состоянии и т.д.
Страница данных, как правило, `8 КБ`, указывается при сборке Postgres.

Когда процессу для выполнения запроса требуются данные, он ищет их сначала в буферном кэше.
Если там их нет, то процесс обращается к ОС.
При этом ОС ищет данные сначала у себя в кэше.
Если не обнаруживает - читает фрагмент данных с диска, кладет их себе в кэш.
Затем Postgres забирает нужную страницу и кладет к себе в буферный кэш.

Посмотрим размер буферного кэша:
```sql
SHOW shared_buffers;

 shared_buffers 
----------------
 128MB
(1 row)
```

Значение по умолчанию слишком мало - `128 МБ`.
В любой реальной системе его требуется увеличить сразу после установки сервера (изменение требует перезапуска).
Условно стандартная рекомендация - начинать примерно с `1/4 объема ОЗУ`, которая доступна экземпляру.


### Вытеснение редко используемых страниц

Когда в кэше заканчиваются свободные буферы, происходит вытеснение страниц с помощью алгоритма `LRU` (`Least Recently Used`).
Т.е. в кеше остаются те страницы, к которым обращаются более часто, остальные вытесняются.

Если процесс изменил данные на странице, соответствующий буфер считается "грязным".
И прежде чем страница будет вытеснена, она будет записана обратно на диск.


### Влияние буферного кэша на выполнение запросов

Создадим таблицу:
```sql
CREATE TABLE t(n integer);

CREATE TABLE
```

Заполним ее некоторым количеством строк:
```sql
INSERT INTO t SELECT id FROM generate_series(1,100000) AS id;

INSERT 0 100000
```

Запустим очистку и анализ этой таблицы, чтобы Postgres понимал, какого размера таблица:
```sql
VACUUM ANALYZE t;

VACUUM
```

Теперь перезапустим сервер, чтобы содержимое буферного кэша сбросилось:
```bash
docker stop postgres-demo

postgres-demo
```
```bash
docker start postgres-demo

postgres-demo
```

Сравним, что происходит при первом и при втором выполнении одного и того же запроса.
Воспользуемся командой `EXPLAIN ANALYZE`, которая выполняет запрос и выводит не только план выполнения, но и дополнительную информацию:
```sql
EXPLAIN (analyze, buffers, costs off, timing off)
SELECT * FROM t;

                 QUERY PLAN
--------------------------------------------
 Seq Scan on t (actual rows=100000 loops=1) 
   Buffers: shared read=443
 Planning:
   Buffers: shared hit=12 read=8 dirtied=1
 Planning Time: 2.668 ms
 Execution Time: 70.465 ms
(6 rows)
```

`Buffers: shared read` - количество буферов, в которые пришлось прочитать страницы с диска (`443 шт`).

Выполним запрос еще раз:
```sql
EXPLAIN (analyze, buffers, costs off, timing off)
SELECT * FROM t;

                 QUERY PLAN                 
--------------------------------------------
 Seq Scan on t (actual rows=100000 loops=1)
   Buffers: shared hit=443
 Planning Time: 0.024 ms
 Execution Time: 4.222 ms
(4 rows)
```

`Buffers: shared hit` - количество буферов, в которых нашлись нужные для запроса страницы (`443 шт`).

Обратите внимание, что во второй раз уменьшилось время выполнения запроса и время его планирования.


## Журнал предварительной записи

Наличие буферного кэша увеличивает производительность, но уменьшает надежность.
В случае сбоя в СУБД содержимое буферного кэша потеряется.
Для обеспечения надежности Postgres использует журнал предварительной записи `WAL` (`Write Ahead Log`).
Это поток информации о выполняемых действиях.

Перед выполнением любой операции со страницей данных, формируется журнальная запись, содержащая минимально необходимую информацию для того, чтобы операцию можно было выполнить повторно.
Журнальная запись попадает на диск (в энергонезависимую память) раньше, чем измененная страница.
Журнал защищает все объекты, работа с которыми ведется в ОЗУ: таблицы, индексы, статусы транзакций и др.

Физически журнал хранится в файлах по `16 МБ` в отдельном каталоге `PGDATA/pg_wal`.
На них можно взглянуть не только в файловой системе, но и с помощью функции:
```sql
SELECT * FROM pg_ls_waldir() ORDER BY name LIMIT 5;

           name           |   size   |      modification      
--------------------------+----------+------------------------
 0000000100000000000000A5 | 16777216 | 2023-11-28 17:34:39+00 
 0000000100000000000000A6 | 16777216 | 2023-11-12 11:53:33+00 
 0000000100000000000000A7 | 16777216 | 2023-11-12 11:53:36+00 
 0000000100000000000000A8 | 16777216 | 2023-11-12 11:55:47+00 
 0000000100000000000000A9 | 16777216 | 2023-11-12 11:53:42+00 
(5 rows)
```

Почему использование журнала эффективнее, чем просто писать изменения на диск?
Журнал - это постоянный поток на запись. Для него обычно используется отдельный физический диск.
В то время как писать страницу на диск - это запись в какое-то произвольное место диска, особенно плохо это работает на крутящемся диске HDD.
Потому что требуется время, чтобы спозиционировать головку на нужную дорожку.
С SSD дисками ситуация лучше.

Логически журнал можно представить в виде непрерывного потока записей.
Каждая запись имеет номер, называемый `LSN` (`Log Sequence Number`).
Это `64-разрядное` число - смещение записи в байтах относительно начала журнала.

Посмотрим текущую позицию:

```sql
SELECT pg_current_wal_lsn();

 pg_current_wal_lsn 
--------------------
 0/A54BF718
(1 row)
```
Позиция записывается как два `32-разрядных` числа через косую черту.

Запомним позицию в переменной "pos1":
```sql
SELECT pg_current_wal_lsn() AS pos1 \gset
```

Теперь выполним какие-нибудь операции и посмотрим, как изменилась позиция:
```sql
CREATE TABLE t(n integer);

CREATE TABLE
```

```sql
INSERT INTO t SELECT gen.id FROM generate_series(1,1000) AS gen(id);

INSERT 0 1000
```

```sql
SELECT pg_current_wal_lsn();

 pg_current_wal_lsn 
--------------------
 0/A54E9F00
(1 row)
```

Позиция изменилась. Запомним ее в переменной "pos2":
```sql
SELECT pg_current_wal_lsn() AS pos2 \gset
```

Найдем разницу между этими позициями в байтах:
```sql
SELECT :'pos2'::pg_lsn - :'pos1'::pg_lsn;

 ?column? 
----------
   221024
(1 row)
```

Примерно `220 КБ` журнала ушло на эти действия.


## Контрольная точка

СУБД периодически выполняет контрольную точку - принудительно сбрасывает все "грязные" буферы на диск.

Когда Postgres запускается после сбоя, он читает журнал предварительной записи, начиная с последней контрольной точки, и последовательно проигрывает каждую запись, если соответствующее изменение не попало на диск.

Postgres автоматически удаляет журнальные файлы, не требующиеся для восстановления.




---
Производительность


Синхронный режим

Запись при фиксации

Обслуживающий процесс


Асинхронный режим

Фоновая запись

walwriter


Режим записи регулируется конфигурационным параметром synchronus commit, его можно устанавливать на лету.








---
Процессы

Процесс записи журнала walwriter

Процесс контрольной точки checkpointer

bgwriter тоже скидывает грязные буферы на диск (скидывает на диск страницы, которые в скором времени будут вытеснены)



-----



Уровни журнала 


Minimal

Гарантия восстановления после сбоя


Replica (по умолчанию)

Резервное копирование

Репликация: передача и проигрывание журнала на другом сервере


Logical

Логическая репликация: информация о добавлении, изменении и удалении табличных строк




----------


## Восстановление при помощи журнала

Измененные табличные страницы находятся в буферном кэше, но еще не записаны на диск.
При обычной остановке сервер выполняет контрольную точку, чтобы записать все грязные страницы на диск,
но мы сымитируем сбой системы, послав сигнал процессу postmaster:

```bash
head -n 1 $PGDATA/postmaster.pid

1
```

```bash
kill -9 1
```
