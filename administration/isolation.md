# Многоверсионность

В файлах данных одновременно могут храниться несколько версий каждой строчки.

Транзакции работают со снимком данных - согласованным срезом на определенный момент времени.

Писатели не блокируют читателей, читатели не блокируют никого.

Время создания снимка влияет на уровень изоляции.

Версии строк накапливаются, поэтому нужна периодическая очистка.

Как убедиться в том, что одна и та же строка может существовать в нескольких версиях?

Создадим таблицу с одной строкой:
```sql
CREATE TABLE t(s text);

CREATE TABLE
```

```sql
INSERT INTO t VALUES ('Первая версия');

INSERT 0 1
```

Начнем транзакцию и выведем ее номер:
```sql
BEGIN;
    
BEGIN
```
```sql
SELECT txid_current();

 txid_current 
--------------
          890
(1 row)
```
В системе мало что происходит, поэтому номер такой маленький.

Транзакция видит первую и пока единственную версию строки:
```sql
SELECT *, xmin, xmax FROM t;

       s       | xmin | xmax 
---------------+------+------
 Первая версия |  889 |    0
(1 row)
```
Вывели несколько вспомогательных полей. Звездочка их не выводит, но если написать явно, мы их увидим.

Здесь мы дополнительно показываем номера транзакций, ограничивающих видимость данной версии строки.
Строка создана предыдущей транзакцией, а xmax = 0 означает, что эта версия актуальна.

xmin - номер транзакции, которая создала версию строки

xmax - номер транзакции, которая удалила версию строки

Теперь начнем другую транзакцию в другом сеансе:
```sql
BEGIN;
    
BEGIN
```

```sql
SELECT txid_current();

 txid_current 
--------------
          891
(1 row)
```
Как видим, номера выдаются по порядку.

Транзакция видит ту же версию строки, потому что пока других версий нет:
```sql
SELECT *, xmin, xmax FROM t;

       s       | xmin | xmax 
---------------+------+------
 Первая версия |  889 |    0
(1 row)
```

Теперь изменим строку во второй транзакции:
```sql
UPDATE t SET s = 'Вторая версия';

UPDATE 1
```
Транзакция, которая этот апдейт выполнила, тут же увидит эти изменения:
```sql
SELECT *, xmin, xmax FROM t;

       s       | xmin | xmax 
---------------+------+------
 Вторая версия |  891 |    0
(1 row)
```

А что увидит первая транзакция?
Поскольку изменения не зафиксированы, первая транзакция продолжает видеть первую версию строки:
```sql
SELECT *, xmin, xmax FROM t;

       s       | xmin | xmax 
---------------+------+------
 Первая версия |  889 |  891
(1 row)
```
Обратите внимание на xmax - значение показывает, что в настоящий момент другая транзакция меняет строку.
Вообще говоря, такое "подглядывание" нарушает изоляцию, поэтому поля xmin и xmax скрытые и в реальной работе их использовать не стоит.

Теперь зафиксируем изменения второй транзакции:
```sql
COMMIT;

COMMIT
```

Что теперь увидит первая транзакция?
Теперь и первая транзакция видит вторую версию строки:
```sql
SELECT *, xmin, xmax FROM t;

---------------+------+------
 Вторая версия |  891 |    0
(1 row)
```

Если и первая транзакция сделает коммит, то не останется никакого снимка данных, в котором первая версия была бы видна.
```sql
COMMIT;

COMMIT
```

Первая версия строки больше не видна ни в одной транзакции и может быть удалена процессом очистки.


## Блокировки

Повторим наш опыт, но теперь пусть обе транзакции попытаются изменить одну и ту же строку.
```sql
BEGIN;
    
BEGIN
```

```sql
UPDATE t SET s = 'Третья версия';

UPDATE 1
```

И во второй транзакции:
```sql
BEGIN;
    
BEGIN
```

```sql
UPDATE t SET s = 'Четвертая версия';

```
Вторая транзакция "повисла" - она не может изменить строку, пока первая транзакция не снимет блокировку.

Коммитим первую транзакцию:
```sql
COMMIT;

COMMIT
```

После того как первая транзакция выполнит коммит, вторая тут же проснется и скажет, что апдейт готов.
```sql

UPDATE 1
```

Теперь мы можем зафиксировать вторую транзакцию:
```sql
COMMIT;

COMMIT
```






--------------
Если мы в psql пишем какую-то команду и перед ней не пишем BEGIN, то Postgres ее автоматически фиксирует.
Т.е. он считает что одна команда - и есть вся транзакция. Грубо говоря оборачивает ее в BEGIN и COMMIT.

При коммите все что происходит - мы устанавливаем статус, что эта транзакция зафиксирована.
Если посмотреть в файл данных (в страничку), то там одновременно лежат эти версии (первая и вторая).
У каждой версии свои значения xmin, xmax.
И любая транзакция, которая хочет прочитать эту строку, выбирает, какую из этих версий ей надо увидеть.

