# Изоляция и многоверсионность

## Транзакции

По умолчанию `psql` работает в режиме автофиксации:
```sh
\echo :AUTOCOMMIT

on
```
Если в `psql` мы пишем какую-то команду и перед ней не пишем `BEGIN`, то Postgres ее автоматически фиксирует.
Он считает, что одна команда - и есть вся транзакция.
Грубо говоря оборачивает ее в `BEGIN` и `COMMIT`.

Посмотрим номер текущей транзакции:
```sql
SELECT txid_current();

 txid_current 
--------------
          886
(1 row)
```
Postgres обернул команду в транзакцию, вывел ее номер и зафиксировал транзакцию.

Еще раз выполним команду:
```sql
SELECT txid_current();

 txid_current 
--------------
          887
(1 row)
```
Видим, что номер увеличился. Номера транзакций выдаются по возрастанию.

## Снимки данных

В Postgres применяется изоляция на основе снимков данных.
Снимок данных - согласованный срез на определенный момент времени.
Номер транзакции определяет момент времени.
Транзакции работают со снимком данных.

В файлах данных одновременно могут храниться несколько версий каждой строки.

Создадим таблицу с одной текстовой колонкой:
```sql
CREATE TABLE t(s text);

CREATE TABLE
```

Добавим строку:
```sql
INSERT INTO t VALUES ('Первая версия');

INSERT 0 1
```

Начнем транзакцию и выведем ее номер:
```sql
BEGIN;
    
BEGIN
```
```sql
SELECT txid_current();

 txid_current 
--------------
          890
(1 row)
```

Транзакция видит первую и пока единственную версию строки:
```sql
SELECT *, xmin, xmax FROM t;

       s       | xmin | xmax 
---------------+------+------
 Первая версия |  889 |    0
(1 row)
```
Вывели несколько вспомогательных полей. Звездочка их не выводит, но если написать явно, мы их увидим.

Здесь мы дополнительно показываем номера транзакций, ограничивающих видимость данной версии строки.
Строка создана предыдущей транзакцией, а xmax = 0 означает, что эта версия актуальна.

xmin - номер транзакции, которая создала версию строки

xmax - номер транзакции, которая удалила версию строки

Теперь начнем другую транзакцию в другом сеансе:
```sql
BEGIN;
    
BEGIN
```

```sql
SELECT txid_current();

 txid_current 
--------------
          891
(1 row)
```
Как видим, номера выдаются по порядку.

Транзакция видит ту же версию строки, потому что пока других версий нет:
```sql
SELECT *, xmin, xmax FROM t;

       s       | xmin | xmax 
---------------+------+------
 Первая версия |  889 |    0
(1 row)
```

Теперь изменим строку во второй транзакции:
```sql
UPDATE t SET s = 'Вторая версия';

UPDATE 1
```
Транзакция, которая этот апдейт выполнила, тут же увидит эти изменения:
```sql
SELECT *, xmin, xmax FROM t;

       s       | xmin | xmax 
---------------+------+------
 Вторая версия |  891 |    0
(1 row)
```

А что увидит первая транзакция?
Поскольку изменения не зафиксированы, первая транзакция продолжает видеть первую версию строки:
```sql
SELECT *, xmin, xmax FROM t;

       s       | xmin | xmax 
---------------+------+------
 Первая версия |  889 |  891
(1 row)
```
Обратите внимание на xmax - значение показывает, что в настоящий момент другая транзакция меняет строку.
Вообще говоря, такое "подглядывание" нарушает изоляцию, поэтому поля xmin и xmax скрытые и в реальной работе их использовать не стоит.

Теперь зафиксируем изменения второй транзакции:
```sql
COMMIT;

COMMIT
```

Что теперь увидит первая транзакция?
Теперь и первая транзакция видит вторую версию строки:
```sql
SELECT *, xmin, xmax FROM t;

---------------+------+------
 Вторая версия |  891 |    0
(1 row)
```

Если и первая транзакция сделает коммит, то не останется никакого снимка данных, в котором первая версия была бы видна.
```sql
COMMIT;

COMMIT
```

Первая версия строки больше не видна ни в одной транзакции и может быть удалена процессом очистки.


## Блокировки

Повторим наш опыт, но теперь пусть обе транзакции попытаются изменить одну и ту же строку.
```sql
BEGIN;
    
BEGIN
```

```sql
UPDATE t SET s = 'Третья версия';

UPDATE 1
```

И во второй транзакции:
```sql
BEGIN;
    
BEGIN
```

```sql
UPDATE t SET s = 'Четвертая версия';

```
Вторая транзакция "повисла" - она не может изменить строку, пока первая транзакция не снимет блокировку.

Коммитим первую транзакцию:
```sql
COMMIT;

COMMIT
```

После того как первая транзакция выполнит коммит, вторая тут же проснется и скажет, что апдейт готов.
```sql

UPDATE 1
```

Теперь мы можем зафиксировать вторую транзакцию:
```sql
COMMIT;

COMMIT
```


## Уровни изоляции

Время создания снимка влияет на уровень изоляции.

`Read Committed` - используется по умолчанию.
Снимок строится на момент начала оператора.
Одинаковые запросы могут каждый раз получать разные данные.

`Repeatable Read` - снимок строится на момент начала первого оператора транзакции.
Транзакция может завершиться ошибкой сериализации.










--------------
Писатели не блокируют читателей, читатели не блокируют никого.

Версии строк накапливаются, поэтому нужна периодическая очистка.

При коммите все что происходит - мы устанавливаем статус, что эта транзакция зафиксирована.
Если посмотреть в файл данных (в страничку), то там одновременно лежат эти версии (первая и вторая).
У каждой версии свои значения xmin, xmax.
И любая транзакция, которая хочет прочитать эту строку, выбирает, какую из этих версий ей надо увидеть.

Когда строка создается, ее версия помечается номером транзакции, выполнившей команду INSERT.

Когда удаляется - номером транзакции, выполнившей DELETE (но физически не удаляется).

UPDATE состоит из двух операций: DELETE и INSERT.






---------

