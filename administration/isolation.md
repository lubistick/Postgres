# Изоляция и многоверсионность

## Транзакции

По умолчанию `psql` работает в режиме автофиксации:
```sh
\echo :AUTOCOMMIT

on
```
Если в `psql` мы пишем какую-то команду и перед ней не пишем `BEGIN`, то Postgres ее автоматически фиксирует.
Он считает, что одна команда - и есть вся транзакция.
Грубо говоря оборачивает ее в `BEGIN` и `COMMIT`.

Посмотрим номер текущей транзакции:
```sql
SELECT txid_current();

 txid_current 
--------------
          886
(1 row)
```
Postgres обернул команду в транзакцию, вывел ее номер и зафиксировал транзакцию.

Еще раз выполним команду:
```sql
SELECT txid_current();

 txid_current 
--------------
          887
(1 row)
```
Видим, что номер увеличился. Номера транзакций выдаются по порядку.

## Снимки данных

В Postgres применяется изоляция на основе снимков данных.
Снимок данных - согласованный срез на определенный момент времени.
Номер транзакции определяет момент времени.
Транзакции работают со снимком данных.

В файлах данных одновременно могут храниться несколько версий каждой строки.

Создадим таблицу с одной текстовой колонкой:
```sql
CREATE TABLE t(s text);

CREATE TABLE
```

Добавим строку:
```sql
INSERT INTO t VALUES ('Первая версия');

INSERT 0 1
```

Начнем транзакцию и выведем ее номер:
```sql
BEGIN;
    
BEGIN
```
```sql
SELECT txid_current();

 txid_current 
--------------
          890
(1 row)
```

Транзакция видит первую и пока единственную версию строки:
```sql
SELECT *, xmin, xmax FROM t;

       s       | xmin | xmax 
---------------+------+------
 Первая версия |  889 |    0
(1 row)
```
Мы вывели номера транзакций, ограничивающих видимость данной версии строки:
- `xmin` - номер транзакции, которая создала версию строки (предыдущая транзакция)
- `xmax` - номер транзакции, которая удалила версию строки (`0` означает, что эта версия актуальна)

Когда строка создается, ее версия помечается номером транзакции, выполнившей команду `INSERT`.
Когда удаляется - номером транзакции, выполнившей `DELETE` (но физически не удаляется).
`UPDATE` состоит из двух операций: `DELETE` и `INSERT`.

Теперь начнем вторую транзакцию в другом сеансе:
```sql
BEGIN;
    
BEGIN
```

```sql
SELECT txid_current();

 txid_current 
--------------
          891
(1 row)
```

Транзакция видит ту же версию строки, потому что пока других версий нет:
```sql
SELECT *, xmin, xmax FROM t;

       s       | xmin | xmax 
---------------+------+------
 Первая версия |  889 |    0
(1 row)
```

Теперь изменим строку во второй транзакции:
```sql
UPDATE t SET s = 'Вторая версия';

UPDATE 1
```

Транзакция, которая этот апдейт выполнила, тут же увидит эти изменения:
```sql
SELECT *, xmin, xmax FROM t;

       s       | xmin | xmax 
---------------+------+------
 Вторая версия |  891 |    0
(1 row)
```

Поскольку изменения не зафиксированы, первая транзакция продолжает видеть "Первую версию" строки:
```sql
SELECT *, xmin, xmax FROM t;

       s       | xmin | xmax 
---------------+------+------
 Первая версия |  889 |  891
(1 row)
```
Обратите внимание на `xmax` - значение показывает, что в настоящий момент другая транзакция меняет строку.

Вообще говоря, такое "подглядывание" нарушает изоляцию, поэтому поля `xmin` и `xmax` скрытые и в реальной работе их использовать не стоит.

Зафиксируем изменения во второй транзакции:
```sql
COMMIT;

COMMIT
```

При коммите Postgres устанавливает статус (1 бит), что транзакция зафиксирована.
В странице одновременно лежат две версии строки - "Первая версия" и "Вторая версия".
У каждой версии свои значения `xmin` и `xmax`.
И любая транзакция, которая хочет прочитать эту строку, выбирает, какую из версий ей надо увидеть.

Теперь и первая транзакция видит "Вторую версию" строки:
```sql
SELECT *, xmin, xmax FROM t;

---------------+------+------
 Вторая версия |  891 |    0
(1 row)
```

Если и первая транзакция сделает коммит, то не останется никакого снимка данных, в котором "Первая версия" была бы видна:
```sql
COMMIT;

COMMIT
```

"Первая версия" строки больше не видна ни в одной транзакции и может быть удалена процессом очистки.


## Блокировки строк

Основные блокировки устанавливаются на уровне строк.

Пусть обе транзакции попытаются изменить одну и ту же строку. Первая транзакция:
```sql
BEGIN;
    
BEGIN
```

```sql
UPDATE t SET s = 'Третья версия';

UPDATE 1
```

Вторая транзакция:
```sql
BEGIN;
    
BEGIN
```

Изменение строки в первой транзакции не блокирует чтение во второй транзакции:
```sql
SELECT * FROM t;

       s       
---------------
 Вторая версия
(1 row)
```

Но изменения строки в первой транзакции заблокирует изменение во второй транзакции:
```sql
UPDATE t SET s = 'Четвертая версия';

```
Вторая транзакция "повисла" - она не может изменить строку, пока первая транзакция не снимет блокировку.

Коммитим первую транзакцию:
```sql
COMMIT;

COMMIT
```

Вторая транзакция тут же делает апдейт, т.к. блокировка была снята:
```sql

UPDATE 1
```

Теперь мы можем зафиксировать вторую транзакцию:
```sql
COMMIT;

COMMIT
```


## Уровни изоляции

Время создания снимка влияет на уровень изоляции.

`Read Committed` - используется по умолчанию.
Снимок строится на момент начала каждого оператора.
Одинаковые запросы могут каждый раз получать разные данные.

`Repeatable Read` - снимок строится на момент начала первого оператора транзакции.
Транзакция может завершиться ошибкой сериализации.







