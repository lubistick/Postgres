# Изоляция и многоверсионность

`Postgres` использует многоверсионность - хранит несколько версий одной и той же строки.
Чтобы отличать версии друг от друга, каждая из них помечается двумя отметками, определяющими время действия версии.
В качестве времени используются номера транзакций.


## Номера транзакций

По умолчанию `psql` работает в режиме автофиксации.
Т.е. если мы пишем какую-то команду и перед ней не пишем `BEGIN`, то `Postgres` ее автоматически фиксирует - грубо говоря оборачивает в `BEGIN` и `COMMIT`.
Он считает, что одна команда - и есть вся транзакция.
За это отвечает переменная `AUTOCOMMIT`:
```sh
\echo :AUTOCOMMIT

on
```

Посмотрим номер текущей транзакции с помощью функции `txid_current()` или `pg_current_xact_id()`.
`Postgres` обернет команду в транзакцию, выведет ее номер и зафиксирует транзакцию:
```sql
SELECT txid_current();

 txid_current 
--------------
          886
(1 row)
```

Номера выдаются по порядку:
```sql
SELECT txid_current();

 txid_current 
--------------
          887
(1 row)
```


## Версии строк

Одна и та же строка может существовать в нескольких версиях.
Транзакция видит только одну версию каждой строки, когда обращается к таблице.

Создадим таблицу с одной текстовой колонкой:
```sql
CREATE TABLE t(s text);

CREATE TABLE
```

Добавим строку:
```sql
INSERT INTO t VALUES ('Первая версия');

INSERT 0 1
```

Начнем первую транзакцию:
```sql
BEGIN;
    
BEGIN
```

Выведем ее номер:
```sql
SELECT txid_current();

 txid_current 
--------------
          890
(1 row)
```

Выведем всю таблицу и скрытые поля `xmin` и `xmax`:
```sql
SELECT *, xmin, xmax FROM t;

       s       | xmin | xmax 
---------------+------+------
 Первая версия |  889 |    0
(1 row)
```
Транзакция видит первую и пока единственную версию строки:
- в поле `xmin` записан номер транзакции `889`, которая создала первую версию строки.
- в поле `xmax` записан `0`, это значит, что первая версия строки актуальна, т.е нет другой транзакции, которая меняет или уже поменяла строку.
Когда строка создается с помощью команды `INSERT`, у нее есть только одна версия.

Теперь начнем вторую транзакцию в другом сеансе:
```sql
BEGIN;
    
BEGIN
```

Выведем ее номер:
```sql
SELECT txid_current();

 txid_current 
--------------
          891
(1 row)
```

Вторая транзакция видит те же значения `xmin` и `xmax`, потому что других версий строки пока нет:
```sql
SELECT *, xmin, xmax FROM t;

       s       | xmin | xmax 
---------------+------+------
 Первая версия |  889 |    0
(1 row)
```

Теперь изменим строку во второй транзакции:
```sql
UPDATE t SET s = 'Вторая версия';

UPDATE 1
```

Вторая транзакция видит вторую версию строки:
```sql
SELECT *, xmin, xmax FROM t;

       s       | xmin | xmax 
---------------+------+------
 Вторая версия |  891 |    0
(1 row)
```
- поле `xmin` имеет значение `891` - эту версию строки создала транзакция номер `891`
- поле `xmax` имеет значение `0` - эта версия актуальна для текущей транзакции

Поскольку изменения не зафиксированы, первая транзакция продолжает видеть первую версию строки:
```sql
SELECT *, xmin, xmax FROM t;

       s       | xmin | xmax 
---------------+------+------
 Первая версия |  889 |  891
(1 row)
```
- поле `xmin` имеет то же значение
- в поле `xmax` записан номер транзакции `891`, это значит, что в настоящий момент другая транзакция меняет строку

Зафиксируем изменения во второй транзакции:
```sql
COMMIT;

COMMIT
```

Теперь и первая транзакция видит вторую версию строки:
```sql
SELECT *, xmin, xmax FROM t;

---------------+------+------
 Вторая версия |  891 |    0
(1 row)
```

Закроем первую транзакцию:
```sql
COMMIT;

COMMIT
```
После фиксации в странице одновременно лежат две версии строки - первая и вторая.
У каждой версии свои значения `xmin` и `xmax`.
Но первая версия строки больше не видна ни в одной транзакции, поэтому может быть удалена [процессом очистки](vacuum.md).

Вообще говоря, такое "подглядывание" нарушает изоляцию, поэтому поля `xmin` и `xmax` скрытые и в реальной работе их использовать не стоит.


### Снимки данных

Транзакции работают со снимками данных. 
Снимок данных создается на определенный момент времени после начала транзакции.
За момент создания снимка отвечает уровень изоляции (`read committed`, `repeatable read`, `serializable`).

Снимок данных - это следующая информация на момент его создания:
- номер последней зафиксированной транзакции
- список активных транзакций

Зная эту информацию, `Postgres` понимает, какая из версий каждой строки будет видна в снимке.

Созданная версия строки помечается номером транзакции, выполнившей команду `INSERT`.
Удаленная версия - номером транзакции, выполнившей `DELETE`.
Обновление версии (`UPDATE`) состоит из двух операций: `DELETE` и `INSERT`.


## Блокировки строк

Многоверсионность позволяет обойтись только самым минимумом блокировок.
Основные блокировки устанавливаются на уровне строк.
Чтение никогда не блокирует ни пишущие, ни читающие транзакции.

Пусть обе транзакции попытаются изменить одну и ту же строку. Первая транзакция:
```sql
BEGIN;
    
BEGIN
```

```sql
UPDATE t SET s = 'Третья версия';

UPDATE 1
```

Вторая транзакция:
```sql
BEGIN;
    
BEGIN
```

Изменение строки в первой транзакции не блокирует чтение во второй транзакции:
```sql
SELECT * FROM t;

       s       
---------------
 Вторая версия
(1 row)
```

Но изменения строки в первой транзакции заблокирует изменение во второй транзакции:
```sql
UPDATE t SET s = 'Четвертая версия';

```
Вторая транзакция "повисла" - она не может изменить строку, пока первая транзакция не снимет блокировку.

Зафиксируем первую транзакцию:
```sql
COMMIT;

COMMIT
```

Вторая транзакция тут же делает апдейт, т.к. блокировка была снята:
```sql

UPDATE 1
```

Теперь мы можем зафиксировать вторую транзакцию:
```sql
COMMIT;

COMMIT
```

Все необходимые блокировки устанавливаются и снимаются автоматически.


## Статус транзакций

Для работы многоверсионности серверу необходимо понимать, в каком статусе находятся транзакции.
Для представления всех состояний каждой транзакции требуется `2 бита`:
- транзакция активна - оба бита установлены в `0`
- транзакция завершена фиксацией (`COMMIT`) - значение первого бита установлено в `1`, второго в `0`
- транзакция завершена обрывом (`ROLLBACK`) - значение первого бита установлено в `0`, второго в `1`

При любом завершении транзакции нужно всего лишь установить соответствующие биты статуса.
И фиксация, и обрыв транзакций происходят одинаково быстро.
При обрыве транзакции не происходит отката данных.
Если прерванная транзакция успела создать новые версии строк, эти версии не уничтожаются.
Благодаря информации о статусах, другие транзакции увидят, что транзакция, создавшая или удалившая версии строк, прервана, и не станут принимать ее изменения во внимание.


## Уровни изоляции

Уровни изоляции отличаются временем создания снимка данных.


### Read Committed

Используется по умолчанию.
Снимок строится на момент начала каждого оператора.
Одинаковые запросы могут каждый раз получать разные данные.

Первая транзакция:
```sql
BEGIN;

BEGIN
```

Прочитаем строки:
```sql
SELECT *, xmin, xmax FROM t;

        s         | xmin | xmax 
------------------+------+------
 Четвертая версия |  903 |  903
(1 row)
```

Удаляем строку во второй транзакции:
```sql
BEGIN;

BEGIN
```

```sql
DELETE FROM t;

DELETE 1
```

Первая транзакция:
```sql
SELECT *, xmin, xmax FROM t;

        s         | xmin | xmax 
------------------+------+------
 Четвертая версия |  903 |  904
(1 row)
```

Вторая транзакция:
```sql
COMMIT;

COMMIT
```

Первая транзакция:
```sql
SELECT *, xmin, xmax FROM t;

 s | xmin | xmax 
---+------+------
(0 rows)
```

```sql
COMMIT;

COMMIT
```


### Repeatable Read

Снимок строится на момент начала первого оператора транзакции.
Транзакция может завершиться ошибкой сериализации.

Вернем строку:
```sql
INSERT INTO t VALUES ('Четвертая версия');

INSERT 0 1
```

Первая транзакция:
```sql
BEGIN;

BEGIN
```

```sql
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;

SET
```

```sql
SELECT *, xmin, xmax FROM t;

        s         | xmin | xmax 
------------------+------+------
 Четвертая версия |  905 |    0
(1 row)
```

Удаляем строку во второй транзакции:
```sql
BEGIN;

BEGIN
```

```sql
DELETE FROM t;

DELETE 1
```

Первая транзакция:
```sql
SELECT *, xmin, xmax FROM t;

        s         | xmin | xmax 
------------------+------+------
 Четвертая версия |  905 |  906
(1 row)
```

Вторая транзакция:
```sql
COMMIT;

COMMIT
```

Первая транзакция:
```sql
SELECT *, xmin, xmax FROM t;

        s         | xmin | xmax 
------------------+------+------
 Четвертая версия |  905 |  906
(1 row)
```
На этом уровне изоляции первая транзакция не видит изменений.

```sql
COMMIT;

COMMIT
```
