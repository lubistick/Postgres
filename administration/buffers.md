# Буферный кэш

В общей памяти экземпляра отводится какой-то кусок памяти, который представляет собой массив буферов.

Каждый буфер хранит в себе одну страницу данных плюс дополнительную информацию - откуда эта страница была прочитана, в каком она состоянии и т.д.

Страница данных, как правило, 8 КБ, указывается при сборке Postgres.

Когда какому-либо процессу для выполнения запроса требуются какие-то данные, он пытается их найти сначала в буферном кэше.

Если там они не нашлись, то процесс обращается к операционной системе и просит ее прочитать соответствующую страницу в буферный кэш.

При этом операционная система ищет данные сначала у себя в кэше.

Если ОС не обнаружила данные у себя в кэше, то она читает фрагмент данных с диска, кладет их себе в кэш, а Postgres оттуда забирает нужную страницу и кладет к себе в кэш.




## Вытеснение редко используемых страниц

В какой-то момент в кэше свободные буферы заканчиваются.

(алгоритм LRU - list reason used)
В кеше остаются те страницы, к которым обращаются более часто. А к которым обращаются редко - вытесняются.

Если мы страницу как-то поменяли, то она считается "грязной" и прежде чем ее выкидывать, ее надо записать обратно на диск.




## Журнал предзаписи (WAL)

Перед тем, как выполнить какое-либо действие со страницей данных, формируется журнальная запись, в которой написано, что мы собираемся поменять.

Журнальная запись должна попасть на диск (в энергонезависимую память) до того, как попадет на диск та страница, которую мы меняем.

Почему это эффективнее, чем просто писать изменения на диск?
Писать страницу на диск - это запись в какое-то произвольное место диска, особенно плохо это работает на крутящемся диске HDD.
Потому что требуется время, чтобы спозиционировать головку на нужную дорожку.
С SSD дисками ситуация лучше, но, тем не менее, такой эффект есть.

А журнал это просто некий постоянный поток на запись. Для него делается обычно отдельный физический диск.

write ahead log

Проблема: при сбое теряются данные из оперативной памяти, не записанные на диск.


Журнал

Поток информации о выполняемых действиях, позволяющий повторно выполнить потерянные при сбое операции

Запись попадает на диск раньше, чем измененные данные


Журнал защищает все, что попадает в буферный кэш.

Страницы таблиц, индексов и других объектов

Статус транзакций (xact)


Журнал не защищает

Временные и нежурналируемые таблицы

---
Производительность


Синхронный режим

Запись при фиксации

Обслуживающий процесс


Асинхронный режим

Фоновая запись

walwriter


Режим записи регулируется конфигурационным параметром synchronus commit, его можно устанавливать на лету.

---


Контрольная точка


Периодический сброс всех грязных буферов на диск

Гарантирует попадание на диск всех изменений до контрольной точки

Ограничивает размер журнала, необходимого для восстановления


Восстановление при сбое

Начинается с последней контрольной точки

Последовательно проигрываются все записи, если изменений нет на диске


---
Процессы

Процесс записи журнала walwriter

Процесс контрольной точки checkpointer

bgwriter тоже скидывает грязные буферы на диск (скидывает на диск страницы, которые в скором времени будут вытеснены)



-----

Логически журнал WAL можно представить в виде непрерывного потока записей.
Каждая запись имеет номер, называемый LSN (Log Sequence Number).
Это 64-разрядное число - смещение записи в байтах относительно начала журнала.

Текущую позицию показывает функция pg_current_wal_lsn:

```sql
SELECT pg_current_wal_lsn();

 pg_current_wal_lsn 
--------------------
 0/A54BF718
(1 row)
```
Позиция записывается как два 32-разрядных числа через косую черту.

Запомним позицию в переменной pos1:
```sql
SELECT pg_current_wal_lsn() AS pos1 \gset
```

Теперь выполним какие-нибудь операции и посмотрим, как изменилась позиция:
```sql
CREATE TABLE t(n integer);

CREATE TABLE
```

```sql
INSERT INTO t SELECT gen.id FROM generate_series(1,1000) AS gen(id);

INSERT 0 1000
```

```sql
SELECT pg_current_wal_lsn();

 pg_current_wal_lsn 
--------------------
 0/A54E9F00
(1 row)
```

Видим, что новая позиция изменилась. Запомним ее:
```sql
SELECT pg_current_wal_lsn() AS pos2 \gset
```

Найдем разницу между этими позициями в байтах:
```sql
SELECT :'pos2'::pg_lsn - :'pos1'::pg_lsn;

 ?column? 
----------
   221024
(1 row)
```

Примерно `220 КБ` журнала ушло на эти действия.

---




Физически журнал хранится в файлах по `16 МБ`, которые называются сегментами, в отдельном каталоге.
На них можно взглянуть не только в файловой системе (`PGDATA/pg_wal`), но и с помощью функции:
```sql
SELECT * FROM pg_ls_waldir() ORDER BY name LIMIT 5;

           name           |   size   |      modification      
--------------------------+----------+------------------------
 0000000100000000000000A5 | 16777216 | 2023-11-28 17:34:39+00 
 0000000100000000000000A6 | 16777216 | 2023-11-12 11:53:33+00 
 0000000100000000000000A7 | 16777216 | 2023-11-12 11:53:36+00 
 0000000100000000000000A8 | 16777216 | 2023-11-12 11:55:47+00 
 0000000100000000000000A9 | 16777216 | 2023-11-12 11:53:42+00 
(5 rows)
```

Postgres удаляет файлы, не требующиеся для восстановления, по мере необходимости.

----------------


Уровни журнала 


Minimal

Гарантия восстановления после сбоя


Replica (по умолчанию)

Резервное копирование

Репликация: передача и проигрывание журнала на другом сервере


Logical

Логическая репликация: информация о добавлении, изменении и удалении табличных строк








