# Буферный кэш

В общей памяти экземпляра отводится какая-то часть памяти, которая представляет собой массив буферов.
Каждый буфер хранит в себе одну страницу данных плюс дополнительную информацию - откуда эта страница была прочитана, в каком она состоянии и т.д.
Страница данных, как правило, `8 КБ`, указывается при сборке Postgres.

Когда процессу для выполнения запроса требуются данные, он ищет их сначала в буферном кэше.
Если там их нет, то процесс обращается к ОС.
При этом ОС ищет данные сначала у себя в кэше.
Если не обнаруживает - читает фрагмент данных с диска, кладет их себе в кэш.
Затем Postgres забирает нужную страницу и кладет к себе в буферный кэш.

Посмотрим размер буферного кэша:
```sql
SHOW shared_buffers;

 shared_buffers 
----------------
 128MB
(1 row)
```

Значение по умолчанию слишком мало - `128 МБ`.
В любой реальной системе его требуется увеличить сразу после установки сервера (изменение требует перезапуска).
Условно стандартная рекомендация - начинать примерно с `1/4 объема ОЗУ`, которая доступна экземпляру.


## Вытеснение редко используемых страниц

Когда в кэше заканчиваются свободные буферы, происходит вытеснение страниц с помощью алгоритма `LRU` (`Least Recently Used`).
Т.е. в кеше остаются те страницы, к которым обращаются более часто, остальные вытесняются.

Если процесс изменил данные на странице, соответствующий буфер считается "грязным".
И прежде чем страница будет вытеснена, она будет записана обратно на диск.


## Влияние буферного кэша на выполнение запросов

Создадим таблицу:
```sql
CREATE TABLE t(n integer);

CREATE TABLE
```

Заполним ее некоторым количеством строк:
```sql
INSERT INTO t SELECT id FROM generate_series(1,100000) AS id;

INSERT 0 100000
```

Запустим очистку и анализ этой таблицы, чтобы Postgres понимал, какого размера таблица:
```sql
VACUUM ANALYZE t;

VACUUM
```

Теперь перезапустим сервер, чтобы содержимое буферного кэша сбросилось:
```bash
docker stop postgres-demo

postgres-demo
```
```bash
docker start postgres-demo

postgres-demo
```

Сравним, что происходит при первом и при втором выполнении одного и того же запроса.

Воспользуемся командой `EXPLAIN ANALYZE`, которая выполняет запрос и выводит не только план выполнения, но и дополнительную информацию:
```sql
EXPLAIN (analyze, buffers, costs off, timing off)
SELECT * FROM t;

                 QUERY PLAN
--------------------------------------------
 Seq Scan on t (actual rows=100000 loops=1) 
   Buffers: shared read=443
 Planning:
   Buffers: shared hit=12 read=8 dirtied=1
 Planning Time: 2.668 ms
 Execution Time: 70.465 ms
(6 rows)
```

`Buffers: shared read` - количество буферов, в которые пришлось прочитать страницы с диска (`443 шт`).

Выполним запрос еще раз:
```sql
EXPLAIN (analyze, buffers, costs off, timing off)
SELECT * FROM t;

                 QUERY PLAN                 
--------------------------------------------
 Seq Scan on t (actual rows=100000 loops=1)
   Buffers: shared hit=443
 Planning Time: 0.024 ms
 Execution Time: 4.222 ms
(4 rows)
```

`Buffers: shared hit` - количество буферов, в которых нашлись нужные для запроса страницы (`443 шт`).

Обратите внимание, что во второй раз уменьшилось время выполнения запроса и время его планирования.


-----

## Журнал предзаписи (WAL)

Перед тем, как выполнить какое-либо действие со страницей данных, формируется журнальная запись, в которой написано, что мы собираемся поменять.

Журнальная запись должна попасть на диск (в энергонезависимую память) до того, как попадет на диск та страница, которую мы меняем.

Почему это эффективнее, чем просто писать изменения на диск?
Писать страницу на диск - это запись в какое-то произвольное место диска, особенно плохо это работает на крутящемся диске HDD.
Потому что требуется время, чтобы спозиционировать головку на нужную дорожку.
С SSD дисками ситуация лучше, но, тем не менее, такой эффект есть.

А журнал это просто некий постоянный поток на запись. Для него делается обычно отдельный физический диск.

write ahead log

Проблема: при сбое теряются данные из оперативной памяти, не записанные на диск.


Журнал

Поток информации о выполняемых действиях, позволяющий повторно выполнить потерянные при сбое операции

Запись попадает на диск раньше, чем измененные данные


Журнал защищает все, что попадает в буферный кэш.

Страницы таблиц, индексов и других объектов

Статус транзакций (xact)


Журнал не защищает

Временные и нежурналируемые таблицы

---
Производительность


Синхронный режим

Запись при фиксации

Обслуживающий процесс


Асинхронный режим

Фоновая запись

walwriter


Режим записи регулируется конфигурационным параметром synchronus commit, его можно устанавливать на лету.

---


Контрольная точка


Периодический сброс всех грязных буферов на диск

Гарантирует попадание на диск всех изменений до контрольной точки

Ограничивает размер журнала, необходимого для восстановления


Восстановление при сбое

Начинается с последней контрольной точки

Последовательно проигрываются все записи, если изменений нет на диске


---
Процессы

Процесс записи журнала walwriter

Процесс контрольной точки checkpointer

bgwriter тоже скидывает грязные буферы на диск (скидывает на диск страницы, которые в скором времени будут вытеснены)



-----

Логически журнал WAL можно представить в виде непрерывного потока записей.
Каждая запись имеет номер, называемый LSN (Log Sequence Number).
Это 64-разрядное число - смещение записи в байтах относительно начала журнала.

Текущую позицию показывает функция pg_current_wal_lsn:

```sql
SELECT pg_current_wal_lsn();

 pg_current_wal_lsn 
--------------------
 0/A54BF718
(1 row)
```
Позиция записывается как два 32-разрядных числа через косую черту.

Запомним позицию в переменной pos1:
```sql
SELECT pg_current_wal_lsn() AS pos1 \gset
```

Теперь выполним какие-нибудь операции и посмотрим, как изменилась позиция:
```sql
CREATE TABLE t(n integer);

CREATE TABLE
```

```sql
INSERT INTO t SELECT gen.id FROM generate_series(1,1000) AS gen(id);

INSERT 0 1000
```

```sql
SELECT pg_current_wal_lsn();

 pg_current_wal_lsn 
--------------------
 0/A54E9F00
(1 row)
```

Видим, что новая позиция изменилась. Запомним ее:
```sql
SELECT pg_current_wal_lsn() AS pos2 \gset
```

Найдем разницу между этими позициями в байтах:
```sql
SELECT :'pos2'::pg_lsn - :'pos1'::pg_lsn;

 ?column? 
----------
   221024
(1 row)
```

Примерно `220 КБ` журнала ушло на эти действия.

---




Физически журнал хранится в файлах по `16 МБ`, которые называются сегментами, в отдельном каталоге.
На них можно взглянуть не только в файловой системе (`PGDATA/pg_wal`), но и с помощью функции:
```sql
SELECT * FROM pg_ls_waldir() ORDER BY name LIMIT 5;

           name           |   size   |      modification      
--------------------------+----------+------------------------
 0000000100000000000000A5 | 16777216 | 2023-11-28 17:34:39+00 
 0000000100000000000000A6 | 16777216 | 2023-11-12 11:53:33+00 
 0000000100000000000000A7 | 16777216 | 2023-11-12 11:53:36+00 
 0000000100000000000000A8 | 16777216 | 2023-11-12 11:55:47+00 
 0000000100000000000000A9 | 16777216 | 2023-11-12 11:53:42+00 
(5 rows)
```

Postgres удаляет файлы, не требующиеся для восстановления, по мере необходимости.

----------------


Уровни журнала 


Minimal

Гарантия восстановления после сбоя


Replica (по умолчанию)

Резервное копирование

Репликация: передача и проигрывание журнала на другом сервере


Logical

Логическая репликация: информация о добавлении, изменении и удалении табличных строк




----------


## Восстановление при помощи журнала

Измененные табличные страницы находятся в буферном кэше, но еще не записаны на диск.
При обычной остановке сервер выполняет контрольную точку, чтобы записать все грязные страницы на диск,
но мы сымитируем сбой системы, послав сигнал процессу postmaster:

```bash
head -n 1 $PGDATA/postmaster.pid

1
```

```bash
kill -9 1
```
