# Очистка

Периодические задачи:
- удаление старых строк и индексов, которые на них ссылаются
- обновление карты видимости
- обновление карты свободного пространства
- обновление статистики

## Автоочистка

Выполнение описанных периодических задач берет на себя фоновый процесс автоочистки.
Он динамически реагирует на частоту обновления таблиц: чем активней изменения, тем чаще таблица будет обрабатываться.

Посмотрим текущие процессы:
```bash
ps

PID   USER     TIME  COMMAND
    1 postgres  0:00 postgres
   23 postgres  0:00 postgres: checkpointer
   24 postgres  0:00 postgres: background writer
   25 postgres  0:00 postgres: walwriter
   26 postgres  0:00 postgres: autovacuum launcher
   27 postgres  0:00 postgres: stats collector
   28 postgres  0:00 postgres: logical replication launcher
   29 root      0:00 sh
   35 root      0:00 ps
```

- `autovacuum launcher` - планирует работу очистки и запускает необходимое число рабочих процессов, работающих параллельно
- `autovacuum worker` - очищает таблицы отдельной базы данных, требующие обработки

Поговорим подробнее про проблемы, которые решает очистка.

### Старые версии строк и индексов

Из-за механизма многоверсионности в табличных страницах накапливаются старые версии строк, а в страницах индексов - ссылки на эти версии.
Со временем не остается ни одного снимка данных, которому требовались бы старые версии строк.
Такие версии называются "мертвыми".

Очистка удаляет:

- мертвые версии строк из таблиц
- записи из индексов, ссылающиеся на мертвые версии строк таблиц


### Карта видимости

Это служебная информация для таблиц.
В ней отмечены страницы, которые содержат только актуальные версии строк, видимые во всех снимках данных.
Применяется для:

- для оптимизации работы процесса очистки
- для оптимизации сканирования только индекса (в индексе нет информации о версионности, если табличная страница отмечена в карте видимости, то видимость можно не проверять).

Очистка поддерживает карту видимости в актуальном состоянии.

### Карта свободного пространства

Это служебная информация для таблиц и индексов. Используется при вставке новых версий строк.
В ней содержится информация о свободном месте внутри страниц. 
При добавлении новых версий строк место уменьшается, при очистке - увеличивается.

Очистка обновляет карту видимости.

### Статистика

Для работы оптимизатора запросов необходима статистика:
- количество строк в таблицах
- распределение данных в столбцах

При сборе статистики читается случайная выборка данных определенного размера.
Это позволяет быстро собрать информацию даже по очень большим таблицам.

Очистка обновляет статистику.


## Запуск вручную

Очистку и анализ можно запустить вручную, с помощью команд `VACUUM` (только очистка), `ANALYZE` (только анализ) и `VACUUM ANALYZE` (очистка и анализ).

Создадим таблицу, отключив для нее автоматическую очистку:
```sql
CREATE TABLE bloat(
  id integer GENERATED ALWAYS AS IDENTITY,
  d timestamptz
) WITH (autovacuum_enabled = off);

CREATE TABLE
```

Заполним таблицу данными:
```sql
INSERT INTO bloat(d) SELECT current_timestamp FROM generate_series(1,100000);

INSERT 0 100000
```

Создадим индекс:
```sql
CREATE INDEX ON bloat(d);

CREATE INDEX
```

Сейчас в таблице `100 000` строк, все строки имеют ровно `1` версию.

Обновим одну строку:
```sql
UPDATE bloat SET d = d + interval '1 day' WHERE id = 1;

UPDATE 1
```

Запустим очистку вручную с выводом подробностей:
```sql
VACUUM (verbose) bloat;

INFO:  vacuuming "bookings.bloat"
INFO:  table "bloat": index scan bypassed: 1 pages from table (0.18% of total) have 1 dead item identifiers
INFO:  table "bloat": found 1 removable, 100000 nonremovable row versions in 541 out of 541 pages
DETAIL:  0 dead row versions cannot be removed yet, oldest xmin: 913
Skipped 0 pages due to buffer pins, 0 frozen pages.
CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s.
VACUUM
```
После выполнения команды:
- из таблицы вычищена 1 версия
- из индекса удалена 1 запись


## Разрастание размера таблиц и индексов

Очистка не уменьшает размер таблиц и индексов.
"Дыры" в страницах используются для новых данных, но место не возвращается операционной системе.

Негативное влияние:
- перерасход места на диске
- замедление последовательного сканирования таблиц
- уменьшение эффективности индексного доступа

Причины разрастания:
- массовое изменение данных
- неправильная настройка автоочистки
- долгие (висящие) транзакции


### Оценка разрастания таблиц и индексов

Понять, насколько критично разрослись объекты и пора ли предпринимать радикальные меры, можно используя расширение `pgstattuple`.

Установим его:
```sql
CREATE EXTENSION pgstattuple;

CREATE EXTENSION
```

С помощью расширения проверим состояние таблицы:
```sql
SELECT * FROM pgstattuple('bloat') \gx

-[ RECORD 1 ]------+--------
table_len          | 4431872
tuple_count        | 100000
tuple_len          | 4000000
tuple_percent      | 90.26
dead_tuple_count   | 0
dead_tuple_len     | 0
dead_tuple_percent | 0
free_space         | 16720
free_percent       | 0.38
```

Колонки:
- `table_len` - размер таблицы
- `tuple_percent` - доля полезной информации (`90 %` - хорошая оценка, она не будет `100 %` из-за накладных расходов)

Проверим состояние индекса:
```sql
SELECT * FROM pgstatindex('bloat_d_idx') \gx

-[ RECORD 1 ]------+-------
version            | 4     
tree_level         | 1     
index_size         | 712704
root_block_no      | 3
internal_pages     | 1
leaf_pages         | 85
empty_pages        | 0
deleted_pages      | 0
avg_leaf_density   | 89.17
leaf_fragmentation | 0
```

Колонки:
- `leaf_pages` - количество листовых страниц индекса
- `avg_leaf_density` - заполненность листовых страниц
- `leaf_fragmentation` - характеристика физической упорядоченности страниц

Теперь обновим сразу половину строк:
```sql
UPDATE bloat SET d = d + interval '1 day' WHERE id % 2 = 0;

UPDATE 50000
```

Посмотрим на таблицу:
```sql
SELECT * FROM pgstattuple('bloat') \gx

-[ RECORD 1 ]------+--------
table_len          | 6643712
tuple_count        | 100000
tuple_len          | 4000000
tuple_percent      | 60.21
dead_tuple_count   | 50000
dead_tuple_len     | 2000000
dead_tuple_percent | 30.1
free_space         | 21000
free_percent       | 0.32
```

- увеличился размер таблицы с `4.4 MB` до `6.6 MB`
- уменьшилась плотность информации с `90 %` до `60 %`

Посмотрим на индекс:
```sql
SELECT * FROM pgstatindex('bloat_d_idx') \gx

-[ RECORD 1 ]------+--------
version            | 4
tree_level         | 1
index_size         | 1081344
root_block_no      | 3
internal_pages     | 1
leaf_pages         | 130
empty_pages        | 0
deleted_pages      | 0
avg_leaf_density   | 87.27
leaf_fragmentation | 0
```

- заполненность листовых страниц осталась на прежнем уровне `87-89 %`
- количество страниц увеличилось с `85` до `130`

### Приблизительная информация

Чтобы не читать всю таблицу целиком, можно попросить `pgstattuple` показать приблизительную информацию:
```sql
SELECT * FROM pgstattuple_approx('bloat') \gx

-[ RECORD 1 ]--------+--------------------
table_len            | 6643712
scanned_percent      | 100
approx_tuple_count   | 100000
approx_tuple_len     | 4000000
approx_tuple_percent | 60.207305795314426
dead_tuple_count     | 50000
dead_tuple_len       | 2000000
dead_tuple_percent   | 30.103652897657213
approx_free_space    | 21000
approx_free_percent  | 0.31608835542540076
```


## Перестроение объектов

Полная очистка.
Полностью перестраивает содержимое таблиц и индексов.
Полностью блокирует работу с таблицей.

Перестроение индексов.
Перестраивает индексы.
Полностью блокирует работу с индексом и блокирует изменение таблицы.

Неблокирующее перестроение индексов.
Перестраивает индексы, не блокируя изменения таблицы.
Выполняется дольше и может завершиться неудачно.
Не транзакционно.
Не работает для системных индексов.
Не работает для индексов, связанных с ограничениями-исключениями.

Для перестроения индексов удобно использовать команду REINDEX с указанием CONCURRENTLY.
Это позволяет не останавливать работу системы на время перестроения:
```sql
REINDEX TABLE CONCURRENTLY bloat;

REINDEX
```

Теперь посмотрим на индекс:
```sql
SELECT * FROM pgstatindex('bloat_d_idx') \gx

-[ RECORD 1 ]------+-------
version            | 4
tree_level         | 1
index_size         | 712704
root_block_no      | 3
internal_pages     | 1
leaf_pages         | 85
empty_pages        | 0
deleted_pages      | 0
avg_leaf_density   | 89.17
leaf_fragmentation | 0
```

Количество листовых страниц и плотность вернулись к начальным значениям.

Для перестроения таблицы вместе с ее индексами можно воспользоваться командой VACUUM FULL.
Однако, в отличие от REINDEX .. CONCURRENTLY, она полностью блокирует работу с таблицей:
```sql
VACUUM FULL bloat;

VACUUM
```

```sql
SELECT * FROM pgstattuple('bloat') \gx

-[ RECORD 1 ]------+--------
table_len          | 4431872
tuple_count        | 100000
tuple_len          | 4000000
tuple_percent      | 90.26
dead_tuple_count   | 0
dead_tuple_len     | 0
dead_tuple_percent | 0
free_space         | 16724
free_percent       | 0.38
```

Плотность увеличилась, освобожденное место отдано операционной системе.









